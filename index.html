<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />









  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="十三&#39;s blog">
<meta property="og:url" content="http://caochenyao.github.io/index.html">
<meta property="og:site_name" content="十三&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十三&#39;s blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> 十三's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">十三's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/26/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-08-26T14:43:40Z" content="2017-08-26">
              2017-08-26
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/24/linux-rout-table/" itemprop="url">
                  路由表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-23T22:30:15Z" content="2016-07-23">
              2016-07-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、路由表的一些介绍<br>路由(名词)数据包从源地址到⽬的地址所经过的路径,由⼀系列路由节点组成。<br>路由(动词）某个路由节点为数据报选择投递⽅向的选路过程。<br>路由节点⼀个具有路由能⼒的主机或路由器,它维护⼀张路由表,通过查询路由表来决定向哪个接⼜发送数据包。<br>在Linux环境下可以通过ifconfig和route查看路由表的信息。<br><img src="http://o6lb63nu0.bkt.clouddn.com/route_01.png" alt="1"><br>路由表由很多路由条⽬组成,每个条⽬都指明去往某个⽹络的数据包应该经由哪个接⼜发送,其中最后⼀条是缺省路由条⽬。<br>路由条⽬路由表中的⼀⾏,每个条⽬主要由⽬的⽹络地址、⼦⽹掩码、下⼀跳地址、发送接⼜四部分组成,如果要发送的数据包的⽬的⽹络地址匹配路由表中的某⼀⾏,就按规定的接⼜发送到下⼀跳地址。<br>缺省路由条⽬路由表中的最后⼀⾏,主要由下⼀跳地址和发送接⼜两部分组成,当⽬的地址与路由表中其它⾏都不匹配时,就按缺省路由条⽬规定的接⼜发送到下⼀跳地址。<br>二、路由算法<br>路由器使用路由算法来找到到达目的地的最佳路由。当说“最佳路由”时，考虑的参数包括诸如跳跃数（分组数据包在网络中从一个路由器或中间节点到另外的节点的行程）、延时以及分组数据包传输通信耗时。关于路由器如何收集网络的结构信息以及对之进行分析来确定最佳路由，有两种主要的路由算法：<br>总体式路由算法和分散式路由算法。采用分散式路由算法时，每个路由器只有与它直接相连的路由器的信息——而没有网络中的每个路由器的信息。这些算法也被称为DV（距离向量）算法。采用总体式路由算法时，每个路由器都拥有网络中所有其他路由器的全部信息以及网络的流量状态。这些算法也被称为LS（链路状态）算法。<br>（一）静态路由算法<br>Dijkstra算法（最短路径算法）<br>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。Dijkstra一般的表述通常有两种方式，一种用永久和临时标号方式，一种是用OPEN, CLOSE表的方式，这里均采用永久和临时标号的方式。注意该算法要求图中不存在负权回路。<br>2.<br>扩散法<br>事先不需要任何网络信息；路由器把收到的每一个分组，向除了该分组到来的线路外的所有输出线路发送。 将来会有多个分组的副本到达目的地端，最先到达的，可能是走了“最优”的路径<br>常见的扩散法是选择性扩散算法。<br>3.<br>基于流量的路由算法<br>既考虑拓扑结构，又兼顾网络负荷；前提：每对结点间平均数据流是相对稳定和可预测的；根据网络带宽和平均流量，可得出平均包延迟，因此路由选择问题归结为找产生网络最小延迟的路由选择算法。提前离线（off-line）计算<br>（二）动态路由算法<br>1.<br>距离向量路由算法<br>距离向量路由算法(Bellman-Ford Routing Algorithm)，也叫做最大流量演算法(Ford-FulkersonAlgorithm)，其被距离向量协议作为一个算法，如RIP, BGP, ISO IDRP, NOVELL IPX。使用这个算法的路由器必须掌握这个距离表(它是一个一维排列-“一个向量”)，它告诉在网络中每个节点的最远和最近距离。在距离表中的这个信息是根据临近接点信息的改变而时时更新的。表中数据的量和在网络中的所有的接点(除了它自己本身)是等同的。这个表中的列代表直接和它相连的邻居，行代表在网络中的所有目的地。每个数据包括传送数据包到每个在网上的目的地的路径和距离/或时间在那个路径上来传输(我们叫这个为“成本”)。这个在那个算法中的度量公式是跳跃的次数，等待时间，流出数据包的数量，等等。在距离向量路由算法中，相邻路由器之间周期性地相互交换各自的路由表备份。当网络拓扑结构发生变化时，路由器之间也将及时地相互通知有关变更信息。<br>水平分裂算法(在发送路由更新消息时进行限制，结点不向相邻结点报告那些从该相邻结点学习到的路由信息<br>2.<br>链路状态最短路由优先算法SPF<br>（1）发现邻居结点，并学习它们的网络地址；<br>（2）测量到各邻居节点的延迟或者开销；<br>（3）创建链路状态分组；<br>（4）使用扩散法发布链路状态分组；<br>（5）计算到每个其它路由器的最短路径。<br>使用Dijkstra算法处理链路信息</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/linux-IP/" itemprop="url">
                  IP数据报分组与重组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-22T21:42:14Z" content="2016-07-22">
              2016-07-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们都知道，不同类型的网络，其MTU（最大传输单元）各不相同，如以太网中，最大的传输帧为1518字节，FDDI为4500字节，令牌环帧在4500字节到17800字节之间，而IP协议的一个重要功能，就是能够对传输的数据大于硬件接口的MTU时，对其进行分段传输。即大于MTU的数据报将被分为2个或多个的合适的大小被传输。一个分片在到达接收主机的路径中，还可能被继续分片，因此，分片的IP数据报可能会以不同的路径传输到接收主机，接收主机通过一系列的重组，将其还原为一个完整的IP数据报，再提交给上层协议处理。<br>一、IP标识符<br>IP标识符、标志、偏移量3个字段在IP报头中的位置如下图所示：<br><img src="http://o6lb63nu0.bkt.clouddn.com/ip_01.png" alt="1"><br>在发送数据报前，发送主机给每个数据报一个ID值，放在16位的标识符字段中。此ID用于标识唯一的数据报或数据流。接收主机利用此ID对收到的数据报进行重组。正如前面所说，当分片的IP数据报从源地址发送到目的地址的时候，由于网络延迟或者不同的传输路径的关系，在到达目的主机时，这些分片数据报并不总是有序的排列，而是处于一种无序状态，因此，接收主机便用此ID判断接收的这些分片数据报是否属于同一个数据流，然后再进行重组（重组将在偏移量中讨论）。</p>
<p>二、标志<br>标志字段在IP报头中占3位，第1位作为保留，置0；第2位，分段，有两个不同的取值：该位置0，表示可以分段；该位置1，表示不能分段；第3位，更多分段，同样有两个取值：该位置0，表示这是数据流中的最后一个分段，该位置1，表示数据流未完，后续还有分段，当一个数据报没有分段时，则该位置0，表示这是唯一的一个分段。<br>当目的主机接收到一个IP数据报时，会首先查看该数据报的标识符，并且检查标志位的第3位是置0或置1，以确定是否还有更多的分段，如果还有后续报文，接收主机则将接收到的报文放在缓存直到接收完所有具有相同标识符的数据报，然后再进行重组。</p>
<p>更多分段位能够让接收主机判断分片的数据报是否发送完毕；而分段位除了能够将将数据报分段，而且还能够实现另一个用途，在某些情况下，可以利用分段位动态的找到网络端到端的MTU大小。如果路由器配置时，置此位为0，则当主机尝试发送一个比传输路径上的数据报大的帧时，路由器不转发该帧，而是丢弃，并给源主机发送ICMP报文，说明该数据报太大，源主机利用此信息调整数据报大小，再重新发送。</p>
<p>3.偏移量<br>13位的偏移量字段用来表示分段的数据报在整个数据流中的位置，即相当于分片数据报的顺序号。发送主机对第一个数据报的偏移量置为0，而后续的分片数据报的偏移量则以网络的MTU大小赋值。偏移量对于接收方进行数据重组的时候，这是一个关键的字段。对于分片的数据段（单位：字节）必须为8的整数倍，否则IP无法表达其偏移量。<br><img src="http://o6lb63nu0.bkt.clouddn.com/ip_02.png" alt="2"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/20/linux-lock/" itemprop="url">
                  产生死锁的条件以及避免死锁的方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-19T20:49:37Z" content="2016-07-19">
              2016-07-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、产生死锁的原因<br>（1） 因为系统资源不足。<br>（2） 进程运行推进的顺序不合适。<br>（3） 资源分配不当等。<br>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。<br>二、产生死锁的必要条件<br>（1）互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。<br>（2）请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。<br>（3）非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。<br>（4）循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。<br>三、怎样避免死锁<br>(1).按同一顺序访问对象。(注：避免出现循环)<br>(2).避免事务中的用户交互。(注：减少持有资源的时间，较少锁竞争)<br>(3).保持事务简短并处于一个批处理中。(注：同(2)，减少持有资源的时间)<br>(4).使用较低的隔离级别。(注：使用较低的隔离级别（例如已提交读）比使用较高的隔离级别（例如可序列化）持有共享锁的时间更短，减少锁竞争)<br>(5).使用基于行版本控制的隔离级别。<br>(6).使用绑定连接。(注：绑定会话有利于在同一台服务器上的多个会话之间协调操作。)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/17/linux-thread-function/" itemprop="url">
                  线程安全和可重入函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-17T15:30:24Z" content="2016-07-17">
              2016-07-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、线程安全与可重入函数<br>(一)线程安全<br>线程安全的概念比较直观。一般说来，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果。<br>1)确保线程安全：<br>要确保函数线程安全，主要需要考虑的是线程之间的共享变量。属于同一进程的不同线程会共享进程内存空间中的全局区和堆，而私有的线程空间则主要包括栈和寄 存器。因此，对于同一进程的不同线程来说，每个线程的局部变量都是私有的，而全局变量、局部静态变量、分配于堆的变量都是共享的。在对这些共享变量进行访 问时，如果要保证线程安全，则必须通过加锁的方式。<br>2)线程不安全的后果：<br>线程不安全可能导致的后果是显而易见的——共享变量的值由于不同线程的访问，可能发生不可预料的变化，进而导致程序的错误，甚至崩溃。<br>(二)可重入函数<br>可重入的概念基本没有比较正式的完整解释，多数的文档都只是说明什么样的情况才能保证函数可重入，但没有完整定义。按照Wiki上的说法，“A computer program or routine is described as reentrant if it can be safely executed concurrently; that is, the routine can be re-entered while it is already running.”根据笔者的经验，所谓“重入”，常见的情况是，程序执行到某个函数foo()时，收到信号，于是暂停目前正在执行的函数，转到信号处理 函数，而这个信号处理函数的执行过程中，又恰恰也会进入到刚刚执行的函数foo()，这样便发生了所谓的重入。此时如果foo()能够正确的运行，而且处 理完成后，之前暂停的foo()也能够正确运行，则说明它是可重入的。<br>1)确保可重入：<br>要确保函数可重入，需满足以下几个条件：<br>1、不在函数内部使用静态或全局数据<br>2、不返回静态或全局数据，所有数据都由函数的调用者提供。<br>3、使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据。<br>4、不调用不可重入函数。<br>2)不可重入的后果：<br>不可重入的后果主要体现在象信号处理函数这样需要重入的情况中。如果信号处理函数中使用了不可重入的函数，则可能导致程序的错误甚至崩溃。<br>二、线程安全与可重入函数的联系与区别<br>可重入与线程安全并不等同。一般说来，可重入的函数一定是线程安全的，但反过来不一定成立。<br>（1）线程安全是在多个线程情况下引发的，而可重入函数可以在只有一个线程的情况下来说。<br>（2）线程安全不一定是可重入的，而可重入函数则一定是线程安全的。<br>（3）如果一个函数中用到了全局或静态变量，那么它不是线程安全的，也不是可重入的。<br>（4）如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数若锁还未释放则会产生死锁，因此是不可重入的。<br>（5）线程安全函数能够使不同的线程访问同一块地址空间，而可重入函数要求不同的执行流对数据的操作互不影响使结果是相同的。<br>（6）如果我们对它加以改进，在访问全局或静态变量时使用互斥量或信号量等方式加锁，则可以使它变成线程安全的，但此时它仍然是不可重入的，因为通常加锁方式是针对不同线程的访问，而对同一线程可能出现问题。<br>（7）如果将函数中的全局或静态变量去掉，改成函数参数等其他形式，则有可能使函数变成既线程安全，又可重入。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/17/linux-semaphore/" itemprop="url">
                  Linux信号量semop函数中的sem_UNDO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-16T20:32:14Z" content="2016-07-16">
              2016-07-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、什么是信号量<br>为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。<br>信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。</p>
<p>二、信号量的工作原理<br>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：<br>P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行<br>V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1<br>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p>
<p>三、Linux中信号量表示的资源操作<br>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们声明在头文件sys/sem.h中。<br>函数semop用以操作一个信号量集，实质是通过修改sem_op指定对资源要进行的操作，semctl函数则是对信号量本身的值进行操作，可以修改信号量的值或者删除一个信号量，这是他们二者容易混淆的地方:</p>
<pre><code>int semop(int semid,struct sembuf semoparray[],size_t nops);
</code></pre><p>semid是通过semget函数返回的一个信号量集标识符ID，nops标明了参数semoparray所指向数组中的元素个数。semoparray是一个结构数组指针。结构体struct sembuf 用来说明要执行的操作。</p>
<pre><code>struct sembuf{
    unsigned short sem_num; //对应信号量集中的某一个资源
    short sem_op;              //指明所要执行的操作
    short sem_flg;            //函数semop的行为
}
</code></pre><p>在sembuf结构中，sem_num是相对应的信号量集中的某一个资源，所以它的值是一个从 0–相对应的信号量集的资源总数（ipc_perm.sem_nsems)之间的整数。<br>sem_op指明想要进行的操作，sem_flg说明函数semop的行为。sem_op的值是一个整数。<br>sem_op：<br>（1）&gt; 0：释放相应的资源数，如果有两个信号量，释放信号量1，则其semval+1，对信号量这个无名结构体的操作，可以通过下面介绍的semctl函数实现。<br>（2）0：进程阻塞直到信号量的相应值为0，当信号量已经为0，函数立即返回。<br>（3）&lt; 0：请求sem_op的绝对值的资源数。<br>sem_flg 参数：<br>该参数可设置为 IPC_NOWAIT 或 SEM_UNDO 两种状态。只有将 sem_flg 指定为 SEM_UNDO 标志后，semadj （所指定信号量针对调用进程的调整值）才会更新。   此外，如果此操作指定SEM_UNDO，系统更新过程中会撤消此信号灯的计数（semadj）。此操作可以随时进行—它永远不会强制等待的过程。调用进程必须有改变信号量集的权限。<br>sem_flg公认的标志是 IPC_NOWAIT 和 SEM_UNDO。如果操作指定SEM_UNDO，它将会自动撤消该进程终止时。<br>在标准操作程序中的操作是在数组的顺序执行、原子的，那就是，该操作要么作为一个完整的单元，要么不。如果不是所有操作都可以立即执行的系统调用的行为取决于在个人sem_flg领域的IPC_NOWAIT标志的存在。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/16/linux-unnamepipe/" itemprop="url">
                  匿名管道与命名管道
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-15T21:08:40Z" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前的博客我们已经了解了管道这一概念，在这篇博客中我们将探讨匿名管道与命名管道。<br>管道(Pipe)实际是用于进程间通信的一段共享内存. 创建管道的进程称为管道服务器，连接到一个管道的进程为管道客户机。<br>一、匿名管道<br>匿名管道，顾名思义，其没有一个标识符来标识它，所以匿名管道只能用于有血缘关系的进程间通信<br>下面是匿名管道的一段代码：</p>
<pre><code> 1 #include&lt;unistd.h&gt;
 2 #include&lt;stdio.h&gt;
 3 #include&lt;errno.h&gt;
 4 #include&lt;sys/types.h&gt;
 5 #include&lt;sys/wait.h&gt;
 6 #include&lt;string.h&gt;
 7 
 8 int main()
 9 {
10     int pipe_fd[2];
11     if(pipe(pipe_fd) &lt; 0)
12     {
13         perror(&quot;pipe&quot;);
14     }
15     
16     pid_t pid = fork();
17     if(pid == 0)
18     {
19         //child
20         close(pipe_fd[0]);
21         const char* msg = &quot;I&apos;m a child\n&quot;;
22         int count = 5;
23         int i = 1;
24         while(1)
25         {
26             write(pipe_fd[1],msg,strlen(msg));
27             if(count-- == 0)
28                 break;
29             sleep(1);
30             printf(&quot;write data:%d\n&quot;,i++);
31         }
32         close(pipe_fd[1]);
33     }
34     else
35     {
36         //father
37         close(pipe_fd[1]);
38         char buf[128];
39         while(1)
40         {
41             memset(buf,&apos;\0&apos;,sizeof(buf));
42             ssize_t s = read(pipe_fd[0],buf,sizeof(buf)-1);
43             if(s &gt; 0)
44             {
45                 printf(&quot;client-&gt;server:%s&quot;,buf);
46             }
47             else if(s == 0)
48             {
49                 printf(&quot;read pipe erro!!!\n&quot;);
50                 break;
51             }
52             else
53             {
54                 break;
55             }
56         }
57         close(pipe_fd[0]);
58 
59         int status = 0;
60         pid_t ret = waitpid(pid,&amp;status,0);
61         if(ret == pid)
62         {
63             printf(&quot;Wait child succeed...\n&quot;);
64         }
65     }
66 
67     return 0;
68 }
</code></pre><p>运行结果如图：<br><img src="http://o6lb63nu0.bkt.clouddn.com/namepipe_01.png" alt="1"><br>二、命名管道<br>命名管道(Named Pipes)是在管道服务器和一台或多台管道客户机之间进行单向或双向通信的一种命名的管道。一个命名管道的所有实例共享同一个管道名，但是每一个实例均拥有独立的缓存与句柄，并且为客户——服务通信提供有一个分离的管道。实例的使用保证了多个管道客户能够在同一时间使用同一个命名管道。<br>命名管道具有很好的使用灵活性，表现在：<br>1) 既可用于本地，又可用于网络。<br>2) 可以通过它的名称而被引用。<br>3) 支持多客户机连接。<br>4) 支持双向通信。<br>5) 支持异步重叠I/O操作。</p>
<p>下面是命名管道的代码部分：<br>客户端：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;sys/types.h&gt;
 3 #include&lt;sys/stat.h&gt;
 4 #include&lt;fcntl.h&gt;
 5 #include&lt;string.h&gt;
 6 
 7 int main()
 8 {
 9     int fd = open(&quot;./myfifo&quot;,O_WRONLY);
10     if(fd &lt; 0)
11     {
12         perror(&quot;open&quot;);
13         return 1;
14     }
15 
16     char buf[128];
17     while(1)
18     {
19         memset(buf,&apos;\0&apos;,sizeof(buf));
20         printf(&quot;Please Enter# &quot;);
21         fflush(stdout);
22         ssize_t s = read(1,buf,sizeof(buf));
23         if(s &gt; 0)
24         {
25             buf[s-1]=&apos;\0&apos;;
26             write(fd,buf,strlen(buf));
27         }
28     }
29     close(fd);
30 
31     return 0;
32 }
</code></pre><p>服务器：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;sys/types.h&gt;
 3 #include&lt;sys/stat.h&gt;
 4 #include&lt;fcntl.h&gt;
 5 #include&lt;string.h&gt;
 6 
 7 int main()
 8 {
 9     if(mkfifo(&quot;./myfifo&quot;,S_IFIFO | 0644) &lt; 0)
10     {
11         perror(&quot;mkfifo&quot;);
12         return 1;
13     }
14 
15     int fd = open(&quot;./myfifo&quot;,O_RDONLY);
16     if(fd &lt; 0)
17     {
18         perror(&quot;open&quot;);
19         return 2;
20     }
21 
22     char buf[128];
23     while(1)
24     {
25         memset(buf,&apos;\0&apos;,sizeof(buf));
26         ssize_t s = read(fd,buf,sizeof(buf)-1);
27         if(s &gt; 0)
28         {
29             printf(&quot;client# %s\n&quot;,buf);
30         }
31         else
32         {
33             break;
34         }
35     }
36 
37     close(fd);
38     return 0;
39 }
</code></pre><p>运行结果如图：<br><img src="http://o6lb63nu0.bkt.clouddn.com/namepipe_02.png" alt="2"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/14/linux-pipe/" itemprop="url">
                  管道内部的组织方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-14T00:05:24Z" content="2016-07-14">
              2016-07-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、管道<br>    管道是一种两个进程间进行单向通信的机制。因为管道传递数据的单向性，管道又称为半双工管道。管道的这一特点决定了其使用的局限性。管道是Linux支持的最初Unix IPC形式之一，具有以下特点：<br>    1)数据只能由一个进程流向另一个进程（其中一个读管道，一个写管道）；如果要进行双工通信，需要建立两个管道。<br>    2)管道只能用于父子进程或者兄弟进程间通信。，也就是说管道只能用于具有亲缘关系的进程间通信。<br>    除了以上局限性，管道还有其他一些不足，如管道没有名字（匿名管道），管道的缓冲区大小是受限制的。管道所传输的是无格式的字节流。这就需要管道输入方和输出方事先约定好数据格式。虽然有那么多不足，但对于一些简单的进程间通信，管道还是完全可以胜任的。<br>    使用管道进行通信时，两端的进程向管道读写数据是通过创建管道时，系统设置的文件描述符进行的。从本质上说，管道也是一种文件，但它又和一般的文件有所不同，可以克服使用文件进行通信的两个问题，这个文件只存在内存中。<br>    通过管道通信的两个进程，一个进程向管道写数据，另外一个从中读数据。写入的数据每次都添加到管道缓冲区的末尾，读数据的时候都是从缓冲区的头部读出数据的。</p>
<p>二、管道的容量<br>在讨论管道内部的组织结构之前我们可以先来测试一下管道的容量：<br>测试管道容量的代码如下：</p>
<pre><code> 1 #include&lt;unistd.h&gt;
 2 #include&lt;stdio.h&gt;
 3 #include&lt;errno.h&gt;
 4 #include&lt;sys/types.h&gt;
 5 #include&lt;sys/wait.h&gt;
 6 #include&lt;string.h&gt;
 7 
 8 int main()
 9 {
10     int pipe_fd[2];
11     if(pipe(pipe_fd) &lt; 0)
12     {
13         perror(&quot;pipe&quot;);
14         return -1;
15     }
16 
17     int ret;
18     int count = 0;
19     while(1)
20     {
21         ret = write(pipe_fd[1], &quot;A&quot;, 1);
22         if(ret &lt; -1)
23         {
24             perror(&quot;write&quot;);
25             return -1;
26         }
27         count++;
28         printf(&quot;pipe capacity:%d\n&quot;,count);
29     }
30     return 0;
31 }
</code></pre><p>测试结果如图所示：<br><img src="http://o6lb63nu0.bkt.clouddn.com/pipe_01.png" alt="1"></p>
<p>三、管道的内部组织方式<br>实际上pipe并没有单独的实现数据结构，他利用了文件的在 Linux 中，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。有两个 file 数据结构，但它们定义文件操作例程地址是不同的，其中一个是向管道中写入数据的例程地址，而另一个是从管道中读出数据的例程地址。这样，用户程序的系统调用仍然是通常的文件操作，而内核却利用这种抽象机制实现了管道这一特殊操作。</p>
<p>PS：VFS（virtual File System）的作用就是采用标准的Unix系统调用读写位于不同物理介质上的不同文件系统,即为各类文件系统提供了一个统一的操作界面和应用编程接口。VFS是一个可以让open()、read()、write()等系统调用不用关心底层的存储介质和文件系统类型就可以工作的粘合层。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/25/linux-fork/" itemprop="url">
                  fork函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-25T14:28:19Z" content="2016-06-25">
              2016-06-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、初步认识fork函数<br>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。<br>来看一个例子：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;unistd.h&gt;
 3 #include&lt;stdlib.h&gt;
 4 
 5 int main()
 6 {
 7     int count = 100;
 8     pid_t pid = fork();
 9 
10     if(pid == -1)
11     {
12         perror(&quot;fork error&quot;);
13         exit(1);
14     }
15     else if(pid == 0)
16     {
17         count++;
18         printf(&quot;child:%d,pid:%d,ppid:%d,count:%d\n&quot;,pid,getpid(),getppid(),count);
19     }
20     else
21     {
22         printf(&quot;parent:%d,pid:%d,ppid:%d,count:%d\n&quot;,pid,getpid(),getppid(),count);
23         sleep(5);
24     }
25 
26     return 0;
27 }
</code></pre><p>其结果如图所示：<br><img src="http://o6lb63nu0.bkt.clouddn.com/fork_1.png" alt="1"><br>如果fork成功，子进程返回的值是0，父进程返回的值是子进程的进程号。<br>而且大家可以发现，在子进程中count进行了加一，但父进程的结果显示父进程的count并没有加一。那是因为父进程创建子进程时，子进程会获得父进程数据空间、堆和栈的副本(主要是数据结构的副本)，也就是说父进程会向子进程拷贝自己的数据空间、堆和栈(主要是数据结构)。所以两者的这些部分是独立的，而两者共享的是正文段(及代码段)。所以在子进程中count++对父进程的count没有影响。</p>
<p>二、深入了解fork函数<br>1.关于子进程通过getppid()获取的父进程进程号为1的问题<br>了解了fork函数的基本功能，再来看看这段代码：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;unistd.h&gt;
 3 #include&lt;stdlib.h&gt;
 4 
 5 int main()
 6 {
 7     int count = 100;
 8     pid_t pid = fork();
 9 
10     if(pid == -1)
11     {
12         perror(&quot;fork error&quot;);
13         exit(1);
14     }
15     else if(pid == 0)
16     {
17         count++;
18         printf(&quot;child:%d,pid:%d,ppid:%d,count:%d\n&quot;,pid,getpid(),getppid(),count);
19     }
20     else
21     {
22         printf(&quot;parent:%d,pid:%d,ppid:%d,count:%d\n&quot;,pid,getpid(),getppid(),count);
23     }
24 
25     return 0;
26 }
</code></pre><p>结果如下图所示：<br><img src="http://o6lb63nu0.bkt.clouddn.com/fork_2.png" alt="2"><br>注意图中所圈的内容，子进程获取的父进程进程号为1，但其父进程的进程号却为6059，这又是什么原因呢？<br>仔细观察代码会发现虽然这个代码与之前的代码很相像，但在父进程这里少了一个sleep函数，那么说明少了这个sleep函数造成了这种现象。因为少了sleep函数，使得父进程在执行完后并没有等待子进程结束就急急忙忙退出了，此时子进程就变成了一个孤儿进程，这个孤儿进程由init接管，所以这里才显示子进程通过getppid()得到的父进程进程号为1。<br>2.关于循环fork进程<br>来看一下这段代码：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;unistd.h&gt;
 3 #include&lt;stdlib.h&gt;
 4 
 5 int main()
 6 {
 7     int i = 0;
 8     pid_t pid;
 9 
10     for(;i&lt;2;i++)
11     {
12         pid = fork();
13         if(pid == -1)
14         {
15             perror(&quot;fork error&quot;);
16             exit(1);
17         }
18         else if(pid == 0)
19         {
20             printf(&quot;child:%d,pid:%d,ppid:%d,i:%d\n&quot;,pid,getpid(),getppid(),i);
21         }
22         else
23         {
24             printf(&quot;parent:%d,pid:%d,ppid:%d,i:%d\n&quot;,pid,getpid(),getppid(),i);
25             sleep(5);
26         }
27     }
28 
29     return 0;
30 }
</code></pre><p>结果如下图示：<br><img src="http://o6lb63nu0.bkt.clouddn.com/fork_3.png" alt="3"><br>一定有六条信息，分析如下图：<br><img src="http://o6lb63nu0.bkt.clouddn.com/fork_4.png" alt="4"><br>最初只有进程号为7003的进程，i=0时，该进程作为父进程创建子进程，进程号为7004；i=1时，父进程再次创建新的子进程，进程号为7006，而子进程也作为父进程创建出进程号为7005的子进程，所以最后的结果为六条信息。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/linux-file/" itemprop="url">
                  FILE结构体
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-24T10:20:52Z" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>struct file结构体定义在/linux/include/linux/fs.h(Linux 2.6.11内核)中，其原型是：</p>
<pre><code>struct file {
        /*
         * fu_list becomes invalid after file_free is called and queued via
         * fu_rcuhead for RCU freeing
         */
        union {
                struct list_head        fu_list;
                struct rcu_head         fu_rcuhead;
        } f_u;
        struct path             f_path;
#define f_dentry        f_path.dentry
#define f_vfsmnt        f_path.mnt
        const struct file_operations    *f_op;
        atomic_t                f_count;
        unsigned int            f_flags;
        mode_t                  f_mode;
        loff_t                  f_pos;
        struct fown_struct      f_owner;
        unsigned int            f_uid, f_gid;
        struct file_ra_state    f_ra;
        unsigned long           f_version;
#ifdef CONFIG_SECURITY
        void                    *f_security;
#endif
        /* needed for tty driver, and maybe others */
        void                    *private_data;
#ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct list_head        f_ep_links;
        spinlock_t              f_ep_lock;
#endif /* #ifdef CONFIG_EPOLL */
        struct address_space    *f_mapping;
};
</code></pre><p>文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核创建和驱动源码中，struct file的指针通常被命名为file或filp。一下是对结构中的每个数据成员的解释：<br>一、</p>
<pre><code>union {
    struct list_head fu_list;
    struct rcu_head rcuhead;
}f_u;
</code></pre><p>其中的struct list_head定义在 linux/include/linux/list.h中，原型为：</p>
<pre><code>struct list_head {
        struct list_head *next, *prev;
};
</code></pre><p>用于通用文件对象链表的指针。</p>
<pre><code>struct rcu_head定义在linux/include/linux/rcupdate.h中，其原型为：
/**
* struct rcu_head - callback structure for use with RCU
* @next: next update requests in a list
* @func: actual update function to call after the grace period.
*/
struct rcu_head {
        struct rcu_head *next;
        void (*func)(struct rcu_head *head);
};
</code></pre><p>二、</p>
<pre><code>struct path             f_path;
</code></pre><p>被定义在linux/include/linux/namei.h中，其原型为：</p>
<pre><code>struct path {
        struct vfsmount *mnt;
        struct dentry *dentry;
};
</code></pre><p>在早些版本的内核中并没有此结构，而是直接将path的两个数据成员作为struct file的数据成员</p>
<pre><code>struct vfsmount *mnt的作用是指出该文件的已安装的文件系统，
struct dentry *dentry是与文件相关的目录项对象。
</code></pre><p>三、</p>
<pre><code>const struct file_operations    *f_op;
</code></pre><p>被定义在linux/include/linux/fs.h中，其中包含着与文件关联的操作，如:</p>
<pre><code>loff_t (*llseek) (struct file *, loff_t, int);
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
</code></pre><p>当打开一个文件时，内核就创建一个与该文件相关联的struct file结构，其中的*f_op就指向的是具体对该文件进行操作的函数。例如用户调用系统调用read来读取该文件的内容时，那么系统调用read最终会陷入内核调用sys_read函数，而sys_read最终会调用于该文件关联的struct file结构中的f_op-&gt;read函数对文件内容进行读取。<br>四、</p>
<pre><code>atomic_t                f_count;
</code></pre><p>atomic_t被定义为：</p>
<pre><code>typedef struct { volatile int counter; } atomic_t;
</code></pre><p>volatile修饰字段告诉gcc不要对该类型的数据做优化处理，对它的访问都是对内存的访问，而不是对寄存器的访问。<br>本质是int类型，之所以这样写是让编译器对基于该类型变量的操作进行严格的类型检查。此处f_count的作用是记录对文件对象的引用计数，也即当前有多少个进程在使用该文件。<br>五、</p>
<pre><code>unsigned int            f_flags;
</code></pre><p>当打开文件时指定的标志，对应系统调用open的int flags参数。驱动程序为了支持非阻塞型操作需要检查这个标志。<br>六、</p>
<pre><code>mode_t                  f_mode;
</code></pre><p>对文件的读写模式，对应系统调用open的mod_t mode参数。如果驱动程序需要这个值，可以直接读取这个字段。<br>mod_t被定义为：</p>
<pre><code>typedef unsigned int __kernel_mode_t;
typedef __kernel_mode_t         mode_t;
</code></pre><p>七、</p>
<pre><code>loff_t                  f_pos;
</code></pre><p>当前的文件指针位置，即文件的读写位置。<br>loff_t被定义为：</p>
<pre><code>typedef long long       __kernel_loff_t;
typedef __kernel_loff_t         loff_t;
</code></pre><p>八、</p>
<pre><code>struct fown_struct      f_owner;
struct fown_struct在linux/include/linux/fs.h被定义，原型为:
struct fown_struct {
        rwlock_t lock;          /* protects pid, uid, euid fields */
        struct pid *pid;        /* pid or -pgrp where SIGIO should be sent */
        enum pid_type pid_type; /* Kind of process group SIGIO should be sent to */
        uid_t uid, euid;        /* uid/euid of process setting the owner */
        int signum;             /* posix.1b rt signal to be delivered on IO */
};
</code></pre><p>该结构的作用是通过信号进行I/O时间通知的数据。<br>九、</p>
<pre><code>unsigned int            f_uid, f_gid;
</code></pre><p>标识文件的所有者id，所有者所在组的id.<br>十、</p>
<pre><code>struct file_ra_state    f_ra;
struct file_ra_state结构被定义在/linux/include/linux/fs.h中，原型为：
struct file_ra_state {
        pgoff_t start;                  /* where readahead started */
        unsigned long size;             /* # of readahead pages */
        unsigned long async_size;       /* do asynchronous readahead when
                                           there are only # of pages ahead */
        unsigned long ra_pages;         /* Maximum readahead window */
        unsigned long mmap_hit;         /* Cache hit stat for mmap accesses */
        unsigned long mmap_miss;        /* Cache miss stat for mmap accesses */
        unsigned long prev_index;       /* Cache last read() position */
        unsigned int prev_offset;       /* Offset where last read() ended in a page */
};
</code></pre><p>文件预读状态，文件预读算法使用的主要数据结构，当打开一个文件时，f_ra中出了perv_page(默认为－1)和ra_apges(对该文件允许的最大预读量)这两个字段外，其他的所有西端都置为0。<br>十一、</p>
<pre><code>unsigned long           f_version;
</code></pre><p>记录文件的版本号，每次使用后都自动递增。<br>十二、</p>
<pre><code>#ifdef CONFIG_SECURITY
        void                    *f_security;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="十三先生" />
          <p class="site-author-name" itemprop="name">十三先生</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caochenyao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5253614710/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十三先生</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
