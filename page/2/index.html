<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />









  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="十三&#39;s blog">
<meta property="og:url" content="http://caochenyao.github.io/page/2/index.html">
<meta property="og:site_name" content="十三&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十三&#39;s blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> 十三's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">十三's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/linux-stickybit/" itemprop="url">
                  粘滞位
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-20T09:29:47Z" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、什么是粘滞位<br>粘滞位(Stickybit)，或粘着位，是Unix文件系统权限的一个旗标。最常见的用法在目录上设置粘滞位，如此以来，只有目录内文件的所有者或者root才可以删除或移动该文件。如果不为目录设置粘滞位，任何具有该目录写和执行权限的用户都可以删除和移动其中的文件。实际应用中，粘滞位一般用于/tmp目录，以防止普通用户删除或移动其他用户的文件。<br>二、粘滞位的功能<br>文件的粘滞位(sticky)位是作什么用的？<br>普通文件的sticky位会被linux内核忽略，<br>目录的sticky位表示这个目录里的文件只能被owner和root删除<br>粘着位(Sticky bit)<br>如果用户对目录有写权限，则可以删除其中的文件和子目录，即使该用户不是这些文件的所有者，而且也没有读或写许可。<br>粘着位出现执行许可的位置上，用t表示，设置了该位后，其它用户就不可以删除不属于他的文件和目录。<br>但是该目录下的目录不继承该权限，要再设置才可使用。 </p>
<pre><code># chmod 1770 xxx  
</code></pre><p>举一个linux下的常见目录来做例子，也就是 /tmp 目录来说一下粘连位的作用。<br><img src="http://o6lb63nu0.bkt.clouddn.com/stickybit_1.png" alt="1"><br>注意orther位置的T，这便是粘连位。<br>我们都知道，/tmp常被我们用来存放临时文件，是所有用户。但是我们不希望别的用户随随便便的就删除了自己的文件，于是便有了粘连位，它的作用便是让用户只能删除属于自己的文件。  </p>
<p>那么原来的执行标志x到哪里去了呢? 系统是这样规定的, 假如本来在该位上有x, 则这些特别标志 (suid, sgid, sticky) 显示为小写字母(s, s, t)。<br> 否则, 显示为大写字母(S, S, T)。<br>3)粘着位(sticky)<br>eg:<br>  chmod 777 abc<br>  chmod +t abc<br>  等价于<br>  chmod 1777 abc<br>在以前旧的系统当中,如果一个程序文件一旦设置了粘着位，那么当该程序中止的时候他的所有指令段将被保存到系统的交换分区当中，再次运行时可以更快的调入系统；不过现在的操作系统已经不再使用这种功能了，但这并不表示这一功能已经完全被废弃。当一个目录设置为粘着位时，它将发挥特殊的作用，即当一个目录被设置为”粘着位”(用chmod a+t),则该目录下的文件只能由<br>1)、超级管理员删除<br>2)、该目录的所有者删除<br>3)、该文件的所有者删除</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/linux-atexit/" itemprop="url">
                  atexit()函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-15T11:05:14Z" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、atexit()函数<br>函数名：atexit<br>头文件：#include&lt;stdlib.h&gt;<br>用法：int atexit(void (*func)(void))<br>注意：按照ISO C的规定，一个进程可以登记多达32个函数，这些函数将由exit自动调用通常这32个函数被称为终止处理程序，并调用atexit函数来登记这些函数，atexit函数被称为终止处理程序注册程序。atexit注册的函数类型应为不接受任何参数void函数，exit调用这些注册函数的顺序与他们登记时候的顺序相反。同一个函数若被登记多次，则也会被调用多次。其中，atexit的参数是一个函数地址。<br>如图例子：<br><img src="http://o6lb63nu0.bkt.clouddn.com/atexit_1.png" alt="1"><br>执行结果如下图：<br><img src="http://o6lb63nu0.bkt.clouddn.com/atexit_2.png" alt="2"><br>根据exit的执行过此可知，exit首先会调用各个终止处理程序，然后按需多次调用fclose(),关闭所有打开流，也就是说exit函数会执行一个标准I/O库的清理关闭操作：对所有打开的流调用fclose()，这样就会造成所有缓冲的输出数据都被冲洗即写入文件中。</p>
<p>内核使程序执行的唯一方法是调用一个exec函数，进程自愿终止的唯一方法是显式或者隐式调用(通过exit函数)_exit()或者_Exit()函数。因此exit函数中实质是对_exit()或者_Exit()函数的封装。exit会先执行自定义的终止处理函数，然后执行I/O库函数清理函数fclose(),这也是为什么可以在终止处理函数中可以继续运用printf之类函数的原因，因为I/O库函数的流对象还没有被清除，当然可以继续运用。执行完了所有的fclose()以后，可以执行真正意义上的终止函数_exit()或者_Exit()函数。</p>
<p>既然这里用到了exit函数，那么我们接下来就来了解一下exit函数<br>二、exit函数<br>要了解exit，首先就要知道exit函数的功能，exit函数是来终止进程的。<br>那么首先来说说进程的终止。<br>1.Linux中进程的终止<br>进程就好比人一样有其生命，我们通过fork()函数来创建一个进程，那么我们又是如何来中止进程呢。<br>进程退出表示进程即将结束。在Linux中进程退出分为了正常退出和异常退出两种。<br>1)正常退出<br>a. 在main()函数中执行return 。<br>b.调用exit()函数<br>c.调用_exit()函数<br>2)异常退出<br>a.调用about函数<br>b.进程收到某个信号，而该信号使程序终止。<br>不管是哪种退出方式，系统最终都会执行内核中的同一代码。这段代码用来关闭进程所用已打开的文件描述符，释放它所占用的内存和其他资源。<br>2.exit函数和_exit函数<br>1)exit和_exit函数都是用来终止进程的。<br>当程序执行到exit或_exit时，系统无条件的停止剩下所有操作，清除包括PCB在内的各种数据结构，并终止本进程的运行。<br>2)exit在头文件stdlib.h中声明，而_exit()声明在头文件unistd.h中声明。 exit中的参数exit_code为０代表进程正常终止，若为其他值表示程序执行过程中有错误发生。<br>3)exit()和_exit()的区别：<br>a._exit()执行后立即返回给内核，而exit()要先执行一些清除操作，然后将控制权交给内核。<br>b. 调用_exit函数时，其会关闭进程所有的文件描述符，清理内存以及其他一些内核清理函数，但不会刷新流(stdin, stdout, stderr …). exit函数是在_exit函数之上的一个封装，其会调用_exit，并在调用之前先刷新流。 </p>
<p>exit()函数与_exit()函数最大区别就在于exit()函数在调用exit系统之前要检查文件的打开情况，把文件缓冲区的内容写回文件。由于Linux的标准函数库中，有一种被称作“缓冲I/O”的操作，其特征就是对应每一个打开的文件，在内存中都有一片缓冲区。每次读文件时，会连续的读出若干条记录，这样在下次读文件时就可以直接从内存的缓冲区读取；同样，每次写文件的时候也仅仅是写入内存的缓冲区，等满足了一定的条件（如达到了一定数量或遇到特定字符等），再将缓冲区中的内容一次性写入文件。这种技术大大增加了文件读写的速度，但也给编程代来了一点儿麻烦。比如有一些数据，认为已经写入了文件，实际上因为没有满足特定的条件，它们还只是保存在缓冲区内，这时用_exit()函数直接将进程关闭，缓冲区的数据就会丢失。因此，要想保证数据的完整性，就一定要使用exit()函数。<br>举个例子进行说明：<br>1）使用exit函数终止进程：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;stdlib.h&gt;
 3 
 4 int main()
 5 {
 6     printf(&quot;exit\n&quot;);
 7     printf(&quot;Hello World&quot;);
 8 
 9     exit(0);
10 }
</code></pre><p> <img src="http://o6lb63nu0.bkt.clouddn.com/atexit_3.png" alt="3"><br>2)使用_exit函数终止进程：</p>
<pre><code> 1 #include&lt;stdio.h&gt;
 2 #include&lt;unistd.h&gt;
 3 
 4 int main()
 5 {
 6     printf(&quot;_exit\n&quot;);
 7     printf(&quot;Hello World&quot;);
 8 
 9     _exit(0);
10 } 
</code></pre><p> <img src="http://o6lb63nu0.bkt.clouddn.com/atexit_4.png" alt="4"><br>在之前的博客中我们已经提到过printf刷新缓冲区的问题，这两个例子可以很明显的看出exit函数会检查文件的打开情况，将缓冲区的内容写回文件，而_exit函数则会直接关闭进程，可能导致缓冲区数据的丢失。                                                                          </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/11/linux-process/" itemprop="url">
                  进程调度算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-11T12:20:00Z" content="2016-06-11">
              2016-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、先来先服务和短作业(进程)优先调度算法<br>1．先来先服务调度算法<br>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</p>
<p>2．短作业(进程)优先调度算法<br>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p>
<p>二、高优先权优先调度算法<br>1．优先权调度算法的类型<br>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</p>
<p>1) 非抢占式优先权算法</p>
<p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p>
<p>2) 抢占式优先权调度算法</p>
<p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p>
<p>2．高响应比优先调度算法<br>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：<br><img src="http://o6lb63nu0.bkt.clouddn.com/process1.png" alt="1"><br>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先权又相当于响应比RP。据此，又可表示为：<br><img src="http://o6lb63nu0.bkt.clouddn.com/process2.png" alt="2"><br>由上式可以看出：</p>
<p>(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</p>
<p>(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p>
<p>(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p>
<p>三、基于时间片的轮转调度算法<br>1．时间片轮转法<br>基本原理：<br>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</p>
<p>2．多级反馈队列调度算法<br>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。</p>
<p>(1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</p>
<p>(2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</p>
<p>(3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/08/linux-task-struct/" itemprop="url">
                  task_struct结构体
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-08T11:03:05Z" content="2016-06-08">
              2016-06-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、进程<br>  进程是处于执行期的程序以及它所管理的资源（如打开的文件、挂起的信号、进程状态、地址空间等等）的总称。注意，程序并不是进程，实际上两个或多个进程不仅有可能执行同一程序，而且还有可能共享地址空间等资源。<br>  Linux内核通过一个被称为进程描述符的task_struct结构体来管理进程，这个结构体包含了一个进程所需的所有信息。它定义在linux-2.6.38.8/include/linux/sched.h文件中。<br>二、task_struct结构体<br>   1.进程状态 </p>
<pre><code>volatile long state;  
int exit_state;
</code></pre><p>   state成员的可能取值如下：</p>
<pre><code>#define TASK_RUNNING        0  
#define TASK_INTERRUPTIBLE  1  
#define TASK_UNINTERRUPTIBLE    2  
#define __TASK_STOPPED      4  
#define __TASK_TRACED       8  
/* in tsk-&gt;exit_state */  
#define EXIT_ZOMBIE     16  
#define EXIT_DEAD       32  
/* in tsk-&gt;state again */  
#define TASK_DEAD       64  
#define TASK_WAKEKILL       128  
#define TASK_WAKING     256 
</code></pre><p>   系统中的每个进程都必然处于以上所列进程状态中的一种。</p>
<pre><code>TASK_RUNNING表示进程要么正在执行，要么正要准备执行。

TASK_INTERRUPTIBLE表示进程被阻塞（睡眠），直到某个条件变为真。条件一旦达成，进程的状态就被设置为TASK_RUNNING。

TASK_UNINTERRUPTIBLE的意义与TASK_INTERRUPTIBLE类似，除了不能通过接受一个信号来唤醒以外。

__TASK_STOPPED表示进程被停止执行。

__TASK_TRACED表示进程被debugger等进程监视。

EXIT_ZOMBIE表示进程的执行被终止，但是其父进程还没有使用wait()等系统调用来获知它的终止信息。

EXIT_DEAD表示进程的最终状态。

EXIT_ZOMBIE和EXIT_DEAD也可以存放在exit_state成员中。
</code></pre><p>   2.进程标识符<br>    pid_t pid;<br>    pid_t tgid;<br>   在CONFIG_BASE_SMALL配置为0的情况下，PID的取值范围是0到32767，即系统中的进程数最大为32768个。</p>
<pre><code>/* linux-2.6.38.8/include/linux/threads.h */  
#define PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000) 
</code></pre><p>   在Linux系统中，一个线程组中的所有线程使用和该线程组的领头线程（该组中的第一个轻量级进程）相同的PID，并被存放在tgid成员中。只有线程组的领头线程的pid成员才会被设置为与tgid相同的值。注意，getpid()系统调用返回的是当前进程的tgid值而不是pid值。</p>
<p>   3.进程内核栈 </p>
<pre><code>void *stack;
</code></pre><p>   进程通过alloc_thread_info函数分配它的内核栈，通过free_thread_info函数释放所分配的内核栈。</p>
<pre><code>/* linux-2.6.38.8/kernel/fork.c */   
static inline struct thread_info *alloc_thread_info(struct task_struct *tsk)  
{  
#ifdef CONFIG_DEBUG_STACK_USAGE  
    gfp_t mask = GFP_KERNEL | __GFP_ZERO;  
#else  
    gfp_t mask = GFP_KERNEL;  
#endif  
    return (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);  
}  
static inline void free_thread_info(struct thread_info *ti)  
{  
    free_pages((unsigned long)ti, THREAD_SIZE_ORDER);  
}  
</code></pre><p>   其中，THREAD_SIZE_ORDER宏在linux-2.6.38.8/arch/arm/include/asm/thread_info.h文件中被定义为1，也就是说alloc_thread_info函数通过调用__get_free_pages函数分配2个页的内存（它的首地址是8192字节对齐的）。<br>   Linux内核通过thread_union联合体来表示进程的内核栈，其中THREAD_SIZE宏的大小为8192。</p>
<pre><code>union thread_union {  
    struct thread_info thread_info;  
    unsigned long stack[THREAD_SIZE/sizeof(long)];  
};  
</code></pre><p>   当进程从用户态切换到内核态时，进程的内核栈总是空的，所以ARM的sp寄存器指向这个栈的顶端。因此，内核能够轻易地通过sp寄存器获得当前正在CPU上运行的进程。</p>
<pre><code>/* linux-2.6.38.8/arch/arm/include/asm/current.h */  
static inline struct task_struct *get_current(void)  
{  
    return current_thread_info()-&gt;task;  
}  

#define current (get_current())  

/* linux-2.6.38.8/arch/arm/include/asm/thread_info.h */   
static inline struct thread_info *current_thread_info(void)  
{  
    register unsigned long sp asm (&quot;sp&quot;);  
    return (struct thread_info *)(sp &amp; ~(THREAD_SIZE - 1));
}
</code></pre><p>   4.标记</p>
<pre><code>unsigned int flags; /* per process flags, defined below */
</code></pre><p>   flags成员的可能取值如下：</p>
<pre><code>#define PF_KSOFTIRQD    0x00000001  /* I am ksoftirqd */  
#define PF_STARTING 0x00000002  /* being created */  
#define PF_EXITING  0x00000004  /* getting shut down */  
#define PF_EXITPIDONE   0x00000008  /* pi exit done on shut down */  
#define PF_VCPU     0x00000010  /* I&apos;m a virtual CPU */  
#define PF_WQ_WORKER    0x00000020  /* I&apos;m a workqueue worker */  
#define PF_FORKNOEXEC   0x00000040  /* forked but didn&apos;t exec */  
#define PF_MCE_PROCESS  0x00000080      /* process policy on mce errors */  
#define PF_SUPERPRIV    0x00000100  /* used super-user privileges */  
#define PF_DUMPCORE 0x00000200  /* dumped core */  
#define PF_SIGNALED 0x00000400  /* killed by a signal */  
#define PF_MEMALLOC 0x00000800  /* Allocating memory */  
#define PF_USED_MATH    0x00002000  /* if unset the fpu must be initialized before use */  
#define PF_FREEZING 0x00004000  /* freeze in progress. do not account to load */  
#define PF_NOFREEZE 0x00008000  /* this thread should not be frozen */  
#define PF_FROZEN   0x00010000  /* frozen for system suspend */  
#define PF_FSTRANS  0x00020000  /* inside a filesystem transaction */  
#define PF_KSWAPD   0x00040000  /* I am kswapd */  
#define PF_OOM_ORIGIN   0x00080000  /* Allocating much memory to others */  
#define PF_LESS_THROTTLE 0x00100000 /* Throttle me less: I clean memory */  
#define PF_KTHREAD  0x00200000  /* I am a kernel thread */  
#define PF_RANDOMIZE    0x00400000  /* randomize virtual address space */  
#define PF_SWAPWRITE    0x00800000  /* Allowed to write to swap */  
#define PF_SPREAD_PAGE  0x01000000  /* Spread page cache over cpuset */  
#define PF_SPREAD_SLAB  0x02000000  /* Spread some slab caches over cpuset */  
#define PF_THREAD_BOUND 0x04000000  /* Thread bound to specific cpu */  
#define PF_MCE_EARLY    0x08000000      /* Early kill for mce process policy */  
#define PF_MEMPOLICY    0x10000000  /* Non-default NUMA mempolicy */  
#define PF_MUTEX_TESTER 0x20000000  /* Thread belongs to the rt mutex tester */  
#define PF_FREEZER_SKIP 0x40000000  /* Freezer should not count it as freezable */  
#define PF_FREEZER_NOSIG 0x80000000 /* Freezer won&apos;t send signals to it */ 
</code></pre><p>   5.表示进程亲属关系的成员</p>
<pre><code>struct task_struct *real_parent; /* real parent process */  
struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */  
struct list_head children;  /* list of my children */  
struct list_head sibling;   /* linkage in my parent&apos;s children list */  
struct task_struct *group_leader;   /* threadgroup leader */ 
</code></pre><p>   在Linux系统中，所有进程之间都有着直接或间接地联系，每个进程都有其父进程，也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。<br>   real_parent指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程。<br>   parent指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与real_parent相同。<br>   children表示链表的头部，链表中的所有元素都是它的子进程。<br>   sibling用于把当前进程插入到兄弟链表中。<br>   group_leader指向其所在进程组的领头进程</p>
<p>   6.ptrace系统调用</p>
<pre><code>unsigned int ptrace;  
struct list_head ptraced;  
struct list_head ptrace_entry;  
unsigned long ptrace_message;  
siginfo_t *last_siginfo; /* For ptrace use.  */  
ifdef CONFIG_HAVE_HW_BREAKPOINT  
atomic_t ptrace_bp_refcnt;  
endif  
</code></pre><p>   成员ptrace被设置为0时表示不需要被跟踪，它的可能取值如下：</p>
<pre><code>/* linux-2.6.38.8/include/linux/ptrace.h */  
#define PT_PTRACED  0x00000001  
#define PT_DTRACE   0x00000002  /* delayed trace (used on m68k, i386) */  
#define PT_TRACESYSGOOD 0x00000004  
#define PT_PTRACE_CAP   0x00000008  /* ptracer can follow suid-exec */  
#define PT_TRACE_FORK   0x00000010  
#define PT_TRACE_VFORK  0x00000020  
#define PT_TRACE_CLONE  0x00000040  
#define PT_TRACE_EXEC   0x00000080  
#define PT_TRACE_VFORK_DONE 0x00000100  
#define PT_TRACE_EXIT   0x00000200 
</code></pre><p>   7.Performance Event</p>
<pre><code>#ifdef CONFIG_PERF_EVENTS  
    struct perf_event_context *perf_event_ctxp[perf_nr_task_contexts];  
    struct mutex perf_event_mutex;  
    struct list_head perf_event_list;  
#endif 
</code></pre><p>   Performance Event是一款随 Linux 内核代码一同发布和维护的性能诊断工具。这些成员用于帮助PerformanceEvent分析进程的性能问题。</p>
<p>   8.进程调度 </p>
<pre><code>int prio, static_prio, normal_prio;  
unsigned int rt_priority;  
const struct sched_class *sched_class;  
struct sched_entity se;  
struct sched_rt_entity rt;  
unsigned int policy;  
cpumask_t cpus_allowed;
</code></pre><p>   实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139）。值越大静态优先级越低。</p>
<pre><code>/* linux-2.6.38.8/include/linux/sched.h */  
#define MAX_USER_RT_PRIO    100  
#define MAX_RT_PRIO     MAX_USER_RT_PRIO  

#define MAX_PRIO        (MAX_RT_PRIO + 40)  
#define DEFAULT_PRIO        (MAX_RT_PRIO + 20)
</code></pre><p>   static_prio用于保存静态优先级，可以通过nice系统调用来进行修改。<br>   rt_priority用于保存实时优先级。<br>   normal_prio的值取决于静态优先级和调度策略。<br>   prio用于保存动态优先级。<br>   policy表示进程的调度策略，目前主要有以下五种：</p>
<pre><code>#define SCHED_NORMAL        0  
#define SCHED_FIFO      1  
#define SCHED_RR        2  
#define SCHED_BATCH     3  
/* SCHED_ISO: reserved but not implemented yet */  
#define SCHED_IDLE      5 
</code></pre><p>   SCHED_NORMAL用于普通进程，通过CFS调度器实现。SCHED_BATCH用于非交互的处理器消耗型进程。SCHED_IDLE是在系统负载很低时使用。<br>   SCHED_FIFO（先入先出调度算法）和SCHED_RR（轮流调度算法）都是实时调度策略。<br>   sched_class结构体表示调度类，目前内核中有实现以下四种：</p>
<pre><code>/* linux-2.6.38.8/kernel/sched_fair.c */   
static const struct sched_class fair_sched_class;  
/* linux-2.6.38.8/kernel/sched_rt.c */  
static const struct sched_class rt_sched_class;  
/* linux-2.6.38.8/kernel/sched_idletask.c */  
static const struct sched_class idle_sched_class;  
/* linux-2.6.38.8/kernel/sched_stoptask.c */  
static const struct sched_class stop_sched_class;
</code></pre><p>   se和rt都是调用实体，一个用于普通进程，一个用于实时进程，每个进程都有其中之一的实体。<br>   cpus_allowed用于控制进程可以在哪里处理器上运行。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/linux-flush/" itemprop="url">
                  Linux缓冲机制——进度条的简单实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-06T08:35:25Z" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、关于printf中’\n’刷新缓冲区的问题<br>   首先看这样的一段代码：</p>
<pre><code>1 #include&lt;stdio.h&gt;
2 #include&lt;unistd.h&gt;
3 
4 int main()
5 {
6     printf(&quot;hello world\n&quot;);
7     sleep(3);                                                
8     return 0;
9 }
</code></pre><p>   运行这段程序的结果是输出”hello world”，再睡眠3秒；<br>   而再运行这一段代码，只有一点小小的差别，结果却不同：</p>
<pre><code>1 #include&lt;stdio.h&gt;
2 #include&lt;unistd.h&gt;
3 
4 int main()
5 {
6     printf(&quot;hello world&quot;); \\去掉了换行符&apos;\n&apos;
7     sleep(3);                                                
8     return 0;
9 }
</code></pre><p>   这段代码与上一段代码的差别在于少了一个换行符’\n’，但是结果却不同，该代码的运行结果是先睡<br>   眠了3秒，再输出”hello world”；<br>   那么问题来了，为什么少了一个换行符会造成两种不同的运行结果，因为printf是一个行缓冲函数，<br>   先写到缓冲区，满足条件后，才将缓冲区刷新到对应文件中，而换行符起到一个刷新缓冲区的作用。<br>   而刷新缓冲区的条件：<br>   1.缓冲区填满<br>   2.写入的字符中有’\n’ ‘\r’<br>   3.调用fflush手动刷新缓冲区<br>   4.调用scanf要从缓冲区中读取数据时，也会将缓冲区内的数据刷新<br>   5.程序结束<br>二、实现进度条<br>   实现代码：</p>
<pre><code> 1 #include&lt;stdio.hiiiiiii&gt;                                                                                              
 2 #include&lt;string.h&gt;
 3 #include&lt;unistd.h&gt;
 4 
 5 void proc()
 6 {
 7     int rate = 0;
 8     char bar[102];                      //进度条
 9     char icon[5] = &quot;|/\\-&quot;;             //动画效果-旋转
10     memset(bar,&apos;\0&apos;,sizeof(char)*102);
11     while(rate &lt; 101)
12     {
13          bar[rate]= &apos;=&apos;;
14          printf(&quot;[%-101s][%d%%][%c]\r&quot;,bar,rate,icon[rate%4]);
15          fflush(stdout);                //刷新缓冲区
16          usleep(100000);                //睡眠时间0.1s
17          rate++;
18     }
19     printf(&quot;\n&quot;);
20 }
21 
22 int main()
23 {
24     proc();
25     return 0;
26 }
</code></pre><p>   编写makefile：</p>
<pre><code>1 proc:proc.c
2     gcc -o proc proc.c                                       
3 .PHONY:clean
4 clean:
5     rm -rf proc
</code></pre><p>   运行结果<br>   <img src="http://o6lb63nu0.bkt.clouddn.com/task1.png" alt="1"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/31/linux-vim/" itemprop="url">
                  vim编辑器的配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-05-31T11:41:01Z" content="2016-05-31">
              2016-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、前言<br>  vim是一款功能强大的文本编辑器，它在vi的基础上增加了很多的特性以及做了很多改进，而学习Linux不免要和vim打交道，本篇博客主要说的是关于vim的配置问题。</p>
<p>二、关于vim的基本配置<br>  当你看到这样的编辑器时你还想继续使用它吗？<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/vim1.png" alt="1"><br>  本人看到这样的编辑器是没有一点继续使用的兴趣了，那么能否将这样一个编译器配置得高大上呢？<br>  首先来看看vim编译器的一些基本配置：<br>  用vim打开~/.vimrc文件，没有的话也没关系，可以自己touch一个，在该文件中写入以下内容：</p>
<pre><code> 1 &quot;显示语法高亮
 2 syntax enable
 3 syntax on
 4 &quot;取消默认注释
 5 set paste
 6 &quot;关于字体颜色的配置
 7 &quot;colorscheme koehler
 8 &quot;colorscheme slate 
 9 colorscheme torte
10 &quot;显示行号
11 set number
12 &quot;历史记录数
13 set history=1000
14 &quot;ai 自动缩进 
15 set autoindent
16 &quot;智能缩进
17 set smartindent
18 &quot;括号匹配
19 set showmatch
20 &quot;开启代码折叠 
21 set foldenable
22 &quot;手动折叠
23 set fdm=manual
24 &quot;自动语法折叠
25 &quot;set foldmethod=syntax
26 &quot;默认制表符为4
27 set tabstop=4
28 set shiftwidth=4
29 &quot;用浅色高亮当前行
30 autocmd InsertLeave * se nocul
31 &quot;用浅色高亮当前行
32 autocmd InsertEnter * se cul
33 &quot;显示标尺
34 set ruler
35 &quot;输入的命令显示出来，看的清楚些
36 set showcmd
37 &quot;设置在vim中可以使用鼠标  --&gt;这个功能较鸡肋，请华丽的忽视它吧
38 &quot;set mouse=a
39 &quot;编码设置
40 set enc=utf-8
41 set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936
42 &quot;语言设置
43 set langmenu=zh_CN.UTF-8
44 set helplang=cn
</code></pre><p>  配置好之后效果图如下：<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/vim2.png" alt="2"><br>  是不是有一种眼前一亮的感觉。</p>
<p>三、vim的一些其他配置<br>  前面讲的那些配置只需要在~/.vimrc文件中写入内容即可，接下来要说的配置不仅要在~/.vimrc文件中写入相关内容还需要下载安装插件。<br>  1.taglist安装<br>  下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=273" target="_blank" rel="noopener">http://www.vim.org/scripts/script.php?script_id=273</a><br>  解压：unzip -d taglist taglist_xx.zip<br>  将解压后将doc/taglist.txt和plugin/taglist.vim中的分别放在~/.vim/doc和~/.vim/plugin两个文件夹中。接下来在~/.vimrc文件中写入以下内容：</p>
<pre><code>45 &quot;*****************************************************
46 &quot;                   taglist配置                      *
47 &quot;*****************************************************
48 
49 &quot;启动vim后自动打开taglist窗口
50 &quot;let Tlist_Auto_Open = 1
51 &quot;不同时显示多个文件的tag，仅显示一个
52 let Tlist_Show_One_File = 1
53 &quot;，退出vim
54 let Tlist_Exit_OnlyWindow = 1
55 &quot;taglist窗口显示在右侧
56 let Tlist_Use_Right_Window = 1
57 &quot;设置taglist窗口大小
58 &quot;let Tlist_WinHeight = 100
59 let Tlist_WinWidth = 25
60 &quot;单击跳转
61 let Tlist_Use_SingClick= 1
62 &quot;设置taglist打开关闭的快捷键F3
63 nnoremap &lt;silent&gt; &lt;F3&gt; :TlistToggle&lt;CR&gt;
</code></pre><p>  配置好之后在命令模式下输入：Tlist，(或者像我一样设置快捷键<f3>，直接按快捷键)结果如图所示：<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/vim3.png" alt="3"><br>  2.NERDTree树状结构配置<br>  下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=1658" target="_blank" rel="noopener">http://www.vim.org/scripts/script.php?script_id=1658</a><br>  解压：unzip -d NERD_tree NERD_tree.zip<br>  解压缩之后，把 plugin/NERD_tree.vim 和doc/NERD_tree.txt分别放到~/.vim/plugin 和 ~/.vim/doc 目录，其他文件直接放在~/.vim目录下。接下来在~/.vimrc中写入以下内容：</f3></p>
<pre><code>64 &quot;********************************************************
65 &quot;                      NERD_Tree 配置                   *
66 &quot;********************************************************
67 
68 &quot;显示增强
69 let NERDChristmasTree= 1
70 &quot;自动调整焦点
71 let NERDTreeAutoCenter= 1
72 &quot;鼠标模式:目录单击,文件双击
73 let NERDTreeMouseMode= 2
74 &quot;打开文件后自动关闭
75 let NERDTreeQuitOnOpen= 1
76 &quot;显示文件
77 let NERDTreeShowFiles= 1
78 &quot;显示隐藏文件
79 let NERDTreeHightCursorline= 1
80 &quot;显示行号
81 let NERDTreeShowLineNumbers= 1
82 &quot;窗口位置
83 let NERDTreeWinPos= &apos;left&apos;
84 &quot;窗口宽度
85 let NERDTreeWinSize= 25
86 &quot;不显示&apos;Bookmarks&apos; label &apos;Press ? for help&apos;
87 let NERDTreeMinimalUI= 1
88 &quot;快捷键
89 nnoremap &lt;silent&gt; &lt;F4&gt; :NERDTreeToggle&lt;CR&gt;
</code></pre><p>   配置好之后在命令模式下输入：NERDTree，(或者像我一样设置快捷键<f4>，直接按快捷键)结果如图所示：<br>   <img src="http://o6lb63nu0.bkt.clouddn.com/vim4.png" alt="4"><br>   3.ctags的使用<br>   在读代码时遇到调用的函数就需要到函数定义的地方看看函数实现的功能，而当代码很多时就不能很快跳转到函数定义的位置，而ctags插件就帮我们解决了这一问题。<br>   下载安装：<br>   方法一、直接输入命令：yum install ctags<br>   方法二、下载压缩包解压安装：<br>         下载地址：<a href="http://www.vim.org/scripts/script.php?script_id=610" target="_blank" rel="noopener">http://www.vim.org/scripts/script.php?script_id=610</a><br>         解压：tar -xzvf ctags-xx.tar.gz<br>         输入命令：cd ctags-xx<br>                  make<br>                  make install   // 需要root权限<br>   在程序所在的目录下输入命令：ctags -R<br>   在该目录下会生成一个tags文件<br>   此时用vim打开文件通过按”ctrl+]”和”ctrl+T”进行跳转。<br>   如图：<br>   <img src="http://o6lb63nu0.bkt.clouddn.com/vim5.png" alt="5"><br>   按”ctrl+]”跳转到函数定义的位置<br>   <img src="http://o6lb63nu0.bkt.clouddn.com/vim6.png" alt="6"><br>   按”ctrl+T”回到函数调用的位置<br>   <img src="http://o6lb63nu0.bkt.clouddn.com/vim7.png" alt="7"><br>   这样配置之后是不是感觉这个文本编辑器相要美观很多。</f4></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/19/linux-1/" itemprop="url">
                  Linux find命令和atime/ctime/mtime
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-05-19T15:40:28Z" content="2016-05-19">
              2016-05-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、Linux中的find命令<br>  1.find命令的一般形式为：<br>   find pathname -options [-print -exec -ok …]</p>
<p>  2.find命令的参数<br>   pathname:find命令所查找的目录路径。例如用.来表示当前目录，用/来表示根目录。<br>   -print:find命令将匹配的文件输出到标准输出。<br>   -exec:find命令对匹配的文件执行该参数所给出的shell命令。相应的命令形式为’command’{} \;，注意{}和\;之间的空格。<br>   -ok:和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</p>
<pre><code>#print将查找到的文件输出到标准输出
#-exec command {} \; ——将查到的文件执行command操作
#-ok和-exec相同，只不过在操作前要询问用户
</code></pre><p>  3.find命令选项<br>    -name<br>     按照文件名查文件<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find1.png" alt="1"><br>    -perm<br>     按照文件权限来查找文件<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find2.png" alt="2"><br>    -prune<br>     使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find3.png" alt="3"><br>    -user<br>     按照文件属主来查找文件<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find4.png" alt="4"><br>    -nouser<br>     查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在<br>    -group<br>     按照文件所属组来查找文件<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find5.png" alt="5"><br>    -nogroup<br>     查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在<br>    -mtime -n +n<br>     按照文件的更改时间来查找文件，-n表示文件更改时间在距现在n天以内，+n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime选项<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find6.png" alt="6"><br>    -newer file1 ! -newer file2<br>     查找更改时间比文件file1新但比文件file2旧的文件<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find7.png" alt="7"><br>    -type<br>     查找某一文件类型，如:<br>     b - 块设备文件<br>     d - 目录<br>     c - 字符设备文件<br>     l - 符号链接文件<br>     f - 普通文件<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find8.png" alt="8"><br>    -size n:[c]<br>     查找文件长度为n块的文件，带有c时表示文件长度以字节计<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find9.png" alt="9"><br>    -depth<br>     在查找文件时，首先查找当期目录中的文件，然后再在其子目录中查找<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find10.png" alt="10"><br>    -fstype<br>     查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/ fstab中找到，该配置文件中包含了本系统中有关文件系统的信息<br>    -mount<br>     在查找文件时不跨越文件系统mount点<br>     <img src="http://o6lb63nu0.bkt.clouddn.com/find11.png" alt="11"><br>    -follow<br>     如果finder命令遇到符号链接文件，就跟踪至链接所指向的文件<br>    -cpio<br>     对配对文件使用cpio命令，将这些文件备份到磁带设备中<br>    -atime/-ctime/-mtime与-amin/-cmin/-mmin的区别<br>     -atime n   ——查找系统中最后n<em>24小时访问的文件<br>     -amin n    ——查找系统中最后n分钟访问的文件<br>     -ctime n   ——查找系统中最后n</em>24小时被改变文件状态的文件<br>     -cmin n    ——查找系统中最后n分钟被改变文件状态的文件<br>     -mtime n   ——查找系统中最后n*24小时被改变文件数据的文件<br>     -mmin n    ——查找系统中最后n分钟被改变文件数据的文件</p>
<p>  4.使用exec或ok来执行shell命令<br>    使用find命令时，只要把想要的操作写在一个文件里，就可以用exec来配合find命令查找，很方便。<br>    在有些操作系统中只允许-exec选项执行诸如ls或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。<br>    exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。</p>
<p>二、Linux中atime/ctime/mtime<br>  使用stat 命令来查询文件的inode信息，其中包括ctime atime mtime<br>  mtime：文件内容改变，ctime文件的状态改变，如chmod权限等。<br>  调整mtime，ctime会变。调整ctime，mtime不一定变化。</p>
<p>  1.文件的atime/ctime/mtime</p>
<pre><code>文件的 Access time，atime 是在读取文件或者执行文件时更改的任何对inode的访问都会使此处改变。
文件的Modified time，mtime 是在写入文件时随文件内容的更改而更改的。
文件的 Change time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。只要stat出来的内容发生改变就会发生改变。mtime的改变必然导致ctime的改变。

mtime （modification time ）：在写入文件时随文件内容的更改而更改的时间。我们用ls -l看到的时间，就是mtime
ctime （status time）：是在写入文件、更改所有者、权限或链接设置时随Inode的内容更改而更改的时间。相当于ls -l –time=ctime所看到的时间
atime （access time）：读取文件或者执行文件时更改的时间。也就是用ls -l –time=atime看到的时间

1）modification time (mtime,修改时间)：这个时间指的是文件内容修改的时间，而不是文件属性的修改，当数据内容修改时，这个时间就会改变，用命令ls -l默认显示的就是这个时间：
2）status time （ctime,状态时间）：当一个文件的状态改变时，这个时间就会改变，例如更改了文件的权限与属性等，它就会改变。
3）access time （atime,访问时间）：当读取文件内容时，就会更改这个时间，例如使用cat去读取/etc/man.config,那么该文件的atime就会改变。
</code></pre><p>  2.文件夹的atime/ctime/mtime</p>
<pre><code>文件夹的 Access time，atime 是在读取文件或者执行文件时更改的（我们只cd进入一个目录然后cd ..不会引起atime的改变，但ls一下就不同了）。
文件夹的 Modified time，mtime 是在文件夹中有文件的新建、删除才会改变（如果只是改变文件内容不会引起mtime的改变，换句话说如果ls -f &lt;directory&gt;的结果发生改变mtime就会被刷新。这里可能有人要争论了：我进入dd这个文件夹vi了一个文件然后退出，前后ls -f &lt;directory&gt;的结果没有改变但是文件夹的mtime发生改变了……这点请主意vi命令在编辑文件时会在本文件夹下产生一 个&quot;.file.swp&quot;临时文件，该文件随着vi的退出而被删除……这就导致了mtime的改变）。
文件夹的 Change time，ctime 基本同文件的ctime，其体现的是inode的change time。

使用find命令时，常为其中的atime/ctime/mtime感到困惑，一直没彻底弄个明白，今天仔细看了以上两篇文章，总算有所领悟，总结如下：
(1)、含义：
   文件的 Access time，atime 是在读取文件或者执行文件时更改的；
   文件的 Modified time，mtime 是在写入文件时随文件内容的更改而更改的；
   文件的 Create time，ctime 是在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改的。
(2)、文件各种事件标记的显示方法
   ls -lc filename         列出文件的 ctime 
   ls -lu filename         列出文件的 atime 
   ls -l filename          列出文件的 mtime 
</code></pre><p>  参数说明<br>  -a ：修改atime<br>  -m ：修改mtime<br>  -c ：仅修改文件的时间（三个时间一起修改），若该文件不存在则不建立新的文件<br>  -d ：后面可以接想修改的日期而不用目前的日期，也可以使用 –date=”日期或时间”<br>  -t ：后面可以接想修改是时间而不用目前的时间，格式为[YYMMDDhhmm]     </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/05/HeapSort/" itemprop="url">
                  堆排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-05-05T15:45:15Z" content="2016-05-05">
              2016-05-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、堆排序<br> 堆排序是通过建立大堆或小堆而实现的一种排序方法。(关于大堆与小堆请参考我的上一篇博客)</p>
<p>二、堆排序的思路<br> 这里我们以实现一组数的升序来进行说明<br> <img src="http://o6lb63nu0.bkt.clouddn.com/HeapSort1.png" alt="1"><br> <img src="http://o6lb63nu0.bkt.clouddn.com/HeapSort2.png" alt="2"></p>
<p>三、堆排序的代码实现</p>
<pre><code>//堆排序-&gt;向下调整
void AdjustDown(int* a, size_t size, size_t root)
{
    assert(a);
    size_t child = root * 2 + 1;
    while (child &lt;size)
    {
        if (a[child] &lt; a[child + 1] &amp;&amp; (child + 1)&lt;size)
        {
            ++child;
        }
        if (a[child] &gt; a[root])
        {
            swap(a[child], a[root]);
            root = child;
            child = root * 2 + 1;
        }
        else
        {
            break;
        }
    }
}
//堆排序-&gt;向上调整
void AdjustUp(int* a, size_t size, size_t parent)
{
    assert(a);
    size_t child = parent * 2 + 1;
    if (a[child] &lt; a[child+1] &amp;&amp; (child+1)&lt;size)
    {
        ++child;
    }
    if (a[child] &gt; a[parent])
    {
        swap(a[child], a[parent]);
    }
}
//堆排序
void HeapSort(int* a, size_t size)
{
    assert(a);
    for (size_t parent = (size - 2)/2; parent &gt; 0;--parent)
    {
        AdjustUp(a,size,parent);
    }
    for (size_t index = size; index &gt; 0;--index)
    {
        AdjustDown(a,index,0);
        swap(a[0],a[index - 1]);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/30/Heap/" itemprop="url">
                  堆
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-04-30T15:44:58Z" content="2016-04-30">
              2016-04-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、堆<br> 1.堆数据结构是一种数组对象，它可以被视为一棵完全二叉树结构。<br> 2.大堆与小堆:<br>   最大堆：每个父节点的都大于孩子节点。<br>   最小堆：每个父节点的都小于孩子节点。<br> 3.堆的每一节点与其两个孩子节点下标的关系:<br>  父节点:parent，左孩子:left，右孩子:right(parent，left，right均为下标)<br>  left = parent<em>2+1，right = parent</em>2+2</p>
<p>二、大堆和小堆的建立<br> <img src="http://o6lb63nu0.bkt.clouddn.com/Heap1.png" alt="1"></p>
<p>三、堆的代码实现<br> 我实现堆使用的是库里的顺序表，没有再自己建立数组</p>
<pre><code>#pragma once
#include&lt;vector&gt;
#include&lt;assert.h&gt;

#pragma warning(disable:4018)

//使用仿函数决定是建大堆还是小堆
template&lt;class T&gt;
struct Less
{
    bool operator()(const T&amp; a, const T&amp; b)
    {
        return a &lt; b;
    }
};

template&lt;class T&gt;
struct Greater
{
    bool operator()(const T&amp; a, const T&amp; b)
    {
        return a &gt; b;
    }
};

template&lt;class T, class Compare = Less&lt;T&gt;&gt;
class Heap
{
public:
    Heap()                            //无参的构造函数
        :_array(NULL)
    {}
    Heap(const T* a, size_t size)     //带参的构造函数
    {
        for (size_t i = 0; i &lt; size; ++i)
        {
            _array.push_back(a[i]);
        }
    }
    void Sort()
    {
        //向上调整
        AdUp(_array.size() - 1);
    }
    void Push(const T&amp; x)                //插入数据
    {
        _array.push_back(x);
        AdUp(_array.size() - 1);
    }
    T&amp; Top()                             //返回堆顶的数据
    {
        assert(_array.size() &gt; 0);
        return _array[0];
    }
    size_t Size()
    {
        return _array.size();
    }
    void Pop()                          //删除堆顶数据
    {
        assert(_array.size() &gt; 0);
        swap(_array[0], _array[_array.size() - 1]);
        _array.pop_back();
        AdDown(0);                      //从堆顶向下进行调整
    }
    bool IsEmpty()                      //判断堆是否为空
    {
        return _array.empty();
    }
protected:
    void AdUp(int child)
    {
        int parent = (child - 1) / 2;    //找到堆的第一个非叶子节点
        while (parent &gt;= 0)              //从该节点依次向上进行调整
        {
            if (child &lt; _array.size() - 1 &amp;&amp; Compare()(_array[child + 1], _array[child]))
            {
                //找出两个叶子节点中小的那一个(建小堆)
                //找出两个叶子节点中大的那一个(建大堆)
                ++child;
            }
            if (Compare()(_array[child], _array[parent]))
            {
                //不符合大堆或小堆的要求，将两个节点交换
                swap(_array[child], _array[parent]);
                //交换后可能会出现之前调整过的又不符合要求，所以要再向下调整
                AdDown(child);
            }
            --parent;
            child = parent * 2 + 1;
        }
    }
    void AdDown(int root)
    {
        int child = root * 2 + 1;
        while (child &lt; _array.size())
        {
            if (child &lt; _array.size() - 1 &amp;&amp; Compare()(_array[child + 1], _array[child]))
            {
                ++child;
            }
            if (Compare()(_array[child], _array[root]))
            {
                swap(_array[child], _array[root]);
                root = child;
                child = root * 2 + 1;
            }
            else
            {
                //此时说明后面的都已经符合要求了，不需要再进行调整
                break;
            }
        }
    }
protected:
    vector&lt;T&gt; _array;
};

void Test()
{
    int array[10] = { 10, 16, 18, 12, 11, 13, 15, 17, 14, 15 };
    Heap&lt;int,Greater&lt;int&gt;&gt; h1(array, 10);

    h1.Sort();
    h1.Push(9);
    h1.Pop();
}
</code></pre><p>在下一篇博客里我们将讨论与堆有关的一个排序——堆排序。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/RBTree/" itemprop="url">
                  红黑树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-04-25T12:06:53Z" content="2016-04-25">
              2016-04-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、什么是红黑树<br> 红黑树是一棵二叉搜索树，它在每个节点上增加了一个存储位来表示节点的颜色，可以是Red或Black。通过对任何一条从根到叶子简单路径上的颜色来约束，红黑树保证最长路径不超过最短路径的两倍，因而近似于平衡。</p>
<p>二、红黑树的性质<br> 1.每个节点，不是红色就是黑色的<br> 2.根节点是黑色的<br> 3.如果一个节点是红色的，则它的两个子节点是黑色的<br> 4.对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</p>
<p>三、红黑树的结构实现<br> <img src="http://o6lb63nu0.bkt.clouddn.com/RB1.png" alt="1"></p>
<p>四、红黑树的插入与平衡调整<br> 我们在这里只讨论红黑树的插入，以及插入节点后平衡树的调整。<br> 当平衡树插入节点后(除根节点外其余插入的的节点均为红色节点)出现插入节点与其父节点都为红色节点时，此时需要对平衡树进行调整。<br> 我们调整时分为以下两大种情况进行调整：<br> (一)第一种情况:<br> cur(新插入的节点)为红，parent(cur的父节点)为红，grandpa(parent的父节点)为黑，uncle(parent的兄弟节点)存在且为红。<br> <img src="http://o6lb63nu0.bkt.clouddn.com/RB2.png" alt="2"><br> <strong>注意:因为这种情况转变后grandpa的颜色变为红色，所以要向上判断grandpa的父节点颜色是否为红，如果颜色为红色就要将grandpa作为新的cur进行调整。</strong><br> (二)第二种情况:<br> cur(新插入的节点)为红，parent(cur的父节点)为红，grandpa(parent的父节点)为黑，uncle(parent的兄弟节点)为黑或不存在。<br> 第二种情况可以分为四种小情况进行讨论:<br> 1.情况A:<br> <img src="http://o6lb63nu0.bkt.clouddn.com/RB3.png" alt="3"><br> <strong>注意:在将grandpa的父节点变为parent前要先将parent的父节点改为grandpa的原父节点。</strong><br> 2.情况B:<br> <img src="http://o6lb63nu0.bkt.clouddn.com/RB4.png" alt="4"><br> <strong>注意:在将grandpa的父节点变为cur前要先将cur的父节点改为grandpa的原父节点。</strong><br> 3.情况C:<br> <img src="http://o6lb63nu0.bkt.clouddn.com/RB5.png" alt="5"><br> <strong>注意:在将grandpa的父节点变为parent前要先将parent的父节点改为grandpa的原父节点。</strong><br> 4.情况D:<br> <img src="http://o6lb63nu0.bkt.clouddn.com/RB6.png" alt="6"><br> <strong>注意:在将grandpa的父节点变为cur前要先将cur的父节点改为grandpa的原父节点。</strong><br> <strong>在调整完之后因为第一种大情况改变了grandpa的颜色，而grandpa有可能是根节点，由于根节点必须为黑色，所以在调整之后需要将根节点的颜色重置为黑色。</strong></p>
<p>五、红黑树的代码实现</p>
<pre><code>#pragma once

enum Color
{
    RED,
    BLACK
};

template&lt;class K,class V&gt;
struct RBTreeNode
{
    RBTreeNode&lt;K, V&gt;* _left;    //左孩子
    RBTreeNode&lt;K, V&gt;* _right;   //右孩子
    RBTreeNode&lt;K, V&gt;* _parent;  //父亲

    K _key;                     //关键字
    V _value;                   //与关键字有关的信息

    Color _col;                 //节点颜色
    //半缺省的构造函数,节点颜色默认为红色,如果出现连续红色节点的话可以调整
    RBTreeNode(const K&amp; key,const V&amp; value,const Color col = RED)
        :_left(NULL)
        , _right(NULL)
        , _parent(NULL)
        , _key(key)
        , _value(value)
        , _col(col)
    {}
};

template&lt;class K,class V&gt;
class RBTree
{
    typedef RBTreeNode&lt;K, V&gt; Node;
public:
    RBTree()
        :_root(NULL)
    {}
    bool Insert(const K&amp; key,const V&amp; value)
    {
        if (_root == NULL)                       //根节点为空直接插入节点
        {
            _root = new Node(key, value, BLACK); //根节点必须是黑色节点
            return true;
        }
        //找到新插入节点的位置
        Node* parent = NULL;
        Node* cur = _root;
        while (cur)
        {
            if (cur-&gt;_key &lt; key)
            {
                parent = cur;
                cur = cur-&gt;_right;
            }    
            else if (cur-&gt;_key &gt; key)
            {
                parent = cur;
                cur = cur-&gt;_left;
            }
            else
                return false;
        }
        //插入新的节点
        cur = new Node(key,value);
        cur-&gt;_parent = parent;
        if (parent-&gt;_key &lt; key)
            parent-&gt;_right = cur;
        else
            parent-&gt;_left = cur;


        Node* uncle = NULL;
        while (parent)
        {
            //判断是否合法(也就是是否有连续的红节点)
            if (cur-&gt;_col == RED &amp;&amp; parent-&gt;_col == RED)
            {
                //找到叔叔节点
                Node* grandpa = parent-&gt;_parent;
                if (grandpa-&gt;_key &lt; parent-&gt;_key)
                    uncle = grandpa-&gt;_left;
                else
                    uncle = grandpa-&gt;_right;

                //分条件判断
                //1.cur为红,parent为红,grandpa为黑,uncle存在且为红
                if (uncle &amp;&amp; uncle-&gt;_col == RED)
                {
                    parent-&gt;_col = uncle-&gt;_col = BLACK;
                    grandpa-&gt;_col = RED;
                    if (grandpa-&gt;_parent &amp;&amp; grandpa-&gt;_parent-&gt;_col == RED)
                    {
                        cur = grandpa;
                        parent = cur-&gt;_parent;
                    }
                    else
                    {
                        break;
                    }
                }
                else  //uncle不存在或者为黑
                {
                    if (parent == grandpa-&gt;_left)
                    {
                        if (cur == parent-&gt;_left)
                        {
                            //右单旋
                            _RotateR(grandpa);
                        }
                        else
                        {
                            //左右双旋
                            _RotateLR(grandpa);
                        }
                        grandpa-&gt;_col = BLACK;
                        grandpa-&gt;_right-&gt;_col = RED;
                    }
                    else
                    {
                        if (cur == parent-&gt;_right)
                        {
                            //左单旋
                            _RotateL(grandpa);
                        }
                        else
                        {
                            //右左双旋
                            _RotateRL(grandpa);
                        }
                        grandpa-&gt;_col = BLACK;
                        grandpa-&gt;_left-&gt;_col = RED;
                    }

                    Node* ppNode = grandpa-&gt;_parent;
                    if (ppNode == NULL)
                    {
                        _root = grandpa;
                        break;
                    }
                    //使之前的grandpa的父节点指向现在的grandpa
                    else
                    {
                        if (ppNode-&gt;_key &gt; grandpa-&gt;_key)
                            ppNode-&gt;_left = grandpa;
                        else
                            ppNode-&gt;_right = grandpa;
                        break;
                    }    
                }    
            }
            else
            {
                break;
            }
        }
        //调整之后可能会出现根节点变为红色节点的情况,要将根节点重新置为黑色
        _root-&gt;_col = BLACK;   
        return true;
    }
    void InOrder()
    {
        _InOrder(_root);
        cout &lt;&lt; endl;
    }
    bool IsBalance()    //判断树是否平衡
    {
        //1.最长路径不超过最短路径的2倍
        //2.对于每个节点，该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点
        //3.没有连续的红色节点
        return BlackCount() &amp;&amp; Color();
    }
    bool BlackCount()
    {
        int left = 0;
        int right = 0;
        return _BlackCount(_root,left,right);
    }
    bool Color()
    {
        return _Color(_root);
    }
protected:
    bool _BlackCount(Node* root,int&amp; left,int&amp; right)
    {
        if (root == NULL)
            return true;
        if (root-&gt;_col == BLACK)
        {
            left = _BlackCount(root-&gt;_left,left,right);
            right = _BlackCount(root-&gt;_right, left, right);
        }
        else
        {
            _BlackCount(root-&gt;_left, left, right);
            _BlackCount(root-&gt;_right, left, right);
        }
        if (left == right)
            return true;
        return false;
    }

    bool _Color(Node* root)
    {
        if (root == NULL)
            return true;
        return _Color(root-&gt;_left) &amp;&amp; _Color(root-&gt;_right) &amp;&amp; Red(root);
    }

    bool Red(Node* root)
    {
        if (root-&gt;_col == RED &amp;&amp; root-&gt;_parent &amp;&amp; root-&gt;_left &amp;&amp; root-&gt;_right)
            return (root-&gt;_col != root-&gt;_parent-&gt;_col &amp;&amp;
                    root-&gt;_col != root-&gt;_left-&gt;_col &amp;&amp;
                    root-&gt;_col != root-&gt;_right-&gt;_col);
        return true;
    }

    void _InOrder(Node* root)
    {
        if (root == NULL)
            return;
        _InOrder(root-&gt;_left);
        cout &lt;&lt; root-&gt;_key &lt;&lt; &quot; &quot;;
        _InOrder(root-&gt;_right);
    }
    void _RotateR(Node*&amp; grandpa)
    {
        Node* parent = grandpa-&gt;_left;       //得到parent节点
        Node* subR = parent-&gt;_right;         //得到parent的右孩子

        grandpa-&gt;_left = subR;               //将subR作为grandpa的左孩子
        if (subR)
            subR-&gt;_parent = grandpa;
        parent-&gt;_right = grandpa;            //将grandpa作为parent的右孩子
        parent-&gt;_parent = grandpa-&gt;_parent;  //parent指向grandpa的父节点
        grandpa-&gt;_parent = parent;           //parent变为grandpa的父节点

        grandpa = parent;
    }
    void _RotateL(Node*&amp; grandpa)
    {
        Node* parent = grandpa-&gt;_right;      //得到parent节点
        Node* subL = parent-&gt;_left;          //得到parent的左孩子

        grandpa-&gt;_right = subL;              //将subL作为grandpa的右孩子
        if (subL)
            subL-&gt;_parent = grandpa;
        parent-&gt;_left = grandpa;             //将grandpa作为parent的左孩子
        parent-&gt;_parent = grandpa-&gt;_parent;  //parent指向grandpa的父节点
        grandpa-&gt;_parent = parent;           //parent变为grandpa的父节点

        grandpa = parent;
    }
    void _RotateRL(Node*&amp; grandpa)
    {
        _RotateR(grandpa-&gt;_right);
        _RotateL(grandpa);
    }
    void _RotateLR(Node*&amp; grandpa)
    {
        _RotateL(grandpa-&gt;_left);
        _RotateR(grandpa);
    }
protected:
    Node* _root;
};

void Test()
{
    RBTree&lt;int, int&gt; rb;
    int a[] = { 16, 3, 7, 11, 9, 26, 18, 14, 15 };
    for (int i = 0; i &lt; sizeof(a)/sizeof(int);++i)
    {
        rb.Insert(a[i],i);
    }

    rb.InOrder();
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="十三先生" />
          <p class="site-author-name" itemprop="name">十三先生</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caochenyao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5253614710/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十三先生</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
