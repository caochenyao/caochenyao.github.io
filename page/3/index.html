<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />









  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.png?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="十三&#39;s blog">
<meta property="og:url" content="http://caochenyao.github.io/page/3/index.html">
<meta property="og:site_name" content="十三&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十三&#39;s blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> 十三's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">十三's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/23/AVLTree/" itemprop="url">
                  二叉平衡搜索树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-04-22T20:26:25Z" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、AVL树<br> AVL树又称为高度平衡的二叉搜索树，是1962年有俄罗斯的数学家G.M.Adel’son-Vel’skii和E.M.Landis提出来的。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度。</p>
<p>二、AVL树的性质<br> 1.左子树和右子树的高度之差的绝对值不超过1<br> 2.树中的每个左子树和右子树都是AVL树<br> 3.每个节点都有一个平衡因子(balance factor–bf),任一节点的平衡因子是-1/0/1。(每个节点的 平衡因子等于右子树的高度减去左子树的高度)</p>
<p>三、AVL树的效率<br>  一棵AVL树有N个节点，其高度可以保持在log2N，插入/删除/查找的时间复杂度也是log2N。<br> (ps：log2N是表示log以2为底N的对数)</p>
<p>四、AVL树的插入<br> 这里我们只讨论AVL树的插入，每插入一个节点，从该节点的父节点向上改变平衡因子，在左子树插入，平衡因子减一，在右子树插入，平衡因子加一:<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL1.png" alt="1"><br> 当某节点的平衡因子改变后变为2或-2时，则要调整平衡因子。<br> 当某节点的平衡因子改变后变为2或-2时，我们可以分为四种情况来讨论平衡因子的调整<br> 1.情况一:改变后平衡因子情况为2，1，0时<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL2.png" alt="2"><br> <strong>注意在parent的父节点变为subR之前要将subR链在parent的原父节点之后。</strong><br> 2.情况二:改变后平衡因子情况为-2，-1，0时<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL3.png" alt="3"><br> <strong>注意在parent的父节点变为subL之前要将subL链在parent的原父节点之后。</strong><br> 3.情况三:改变后平衡因子情况为2，-1，0时<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL4.png" alt="4"><br> <strong>注意在parent的父节点变为subRL之前要将subRL链在parent的原父节点之后。</strong><br> 旋转之后需要调整平衡因子<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL5.png" alt="5"><br> 4.情况四:改变后平衡因子情况为-2，1，0时<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL6.png" alt="6"><br> <strong>注意在parent的父节点变为subLR之前要将subLR链在parent的原父节点之后。</strong><br> 旋转之后需要调整平衡因子<br> <img src="http://o6lb63nu0.bkt.clouddn.com/AVL7.png" alt="7"></p>
<p>五、AVL树的代码实现<br> 我实现AVL树使用的是非递归的方法</p>
<pre><code>#pragma once
//AVL树节点的实现，这里使用的是三叉链的结构
template&lt;class K,class V&gt;
struct AVLTreeNode
{
    AVLTreeNode&lt;K, V&gt;* _left;     //左孩子
    AVLTreeNode&lt;K, V&gt;* _right;    //右孩子
    AVLTreeNode&lt;K, V&gt;* _parent;   //父节点
    K _key;                       //关键字
    V _value;                     //与关键字有关的信息
    int _bf;                      //平衡因子

    AVLTreeNode(const K&amp; key,const V&amp; value) //构造函数
        :_left(NULL)
        , _right(NULL)
        , _parent(NULL)
        , _key(key)
        , _value(value)
        , _bf(0)
    {}
};

template&lt;class K,class V&gt;
class AVLTree
{
    typedef AVLTreeNode&lt;K, V&gt; Node;
public:
    AVLTree()                           //构造函数
        :_root(NULL)
    {}
public:
    bool Insert(const K&amp; key,const V&amp; value)  //AVL树的插入
    {
        if (_root == NULL)
        {
            _root = new Node(key, value);
            return true;
        }

        Node* parent = NULL;
        Node* cur = _root;
        bool Isadjust = false;
        while (cur)                         //找到插入的位置
        {
            if (cur-&gt;_key &lt; key)
            {
                parent = cur;
                cur = cur-&gt;_right;
            }
            else if (cur-&gt;_key &gt; key)
            {
                parent = cur;
                cur = cur-&gt;_left;
            }
            else
            {
                return false;
            }    
        }

        cur = new Node(key,value);         //创建新节点
        cur-&gt;_parent = parent;             //插入新节点
        if (cur-&gt;_key &lt; parent-&gt;_key)
        {
            parent-&gt;_left = cur;
        }
        else
        {
            parent-&gt;_right = cur;
        }

        while (parent)                    //由父节点向上修改平衡因子
        {

            if (cur == parent-&gt;_left)
            {
                parent-&gt;_bf--;
                if (parent-&gt;_bf == 0)
                    break;
            }
            else if (cur == parent-&gt;_right)
            {
                parent-&gt;_bf++;
                if (parent-&gt;_bf == 0)
                    break;
            }
            //当某一节点的平衡因子为2或-2时，调整平衡因子
            if (parent-&gt;_bf &gt; 1 || parent-&gt;_bf &lt; -1)
            {
                Isadjust = true;
                if (parent-&gt;_bf &gt; 1)
                {
                    if (parent-&gt;_right-&gt;_bf == 1)
                    {
                        //情况为2,1,0;为左单旋
                        _RotateL(parent);
                    }
                    else if (parent-&gt;_right-&gt;_bf == -1)
                    {
                        //情况为2,-1,0;为右左双旋
                        _RotateRL(parent);
                    }
                }
                else
                {
                    if (parent-&gt;_left-&gt;_bf == -1)
                    {
                        //情况为-2,-1,0;为右单旋
                        _RotateR(parent);
                    }
                    else if (parent-&gt;_left-&gt;_bf == 1)
                    {
                        //情况为-2,1,0;为为左右双旋
                        _RotateLR(parent);
                    }
                }
                if (parent-&gt;_parent == NULL)
                {
                    _root = parent;
                    return true;
                }
            }

            Node* ppNode = parent-&gt;_parent;
            if (Isadjust &amp;&amp; ppNode)
            {
                if (parent-&gt;_key &lt; ppNode-&gt;_key)
                {
                    ppNode-&gt;_left = parent;
                }
                else
                {
                    ppNode-&gt;_right = parent;
                }
                return true;
            }
            cur = parent;
            parent = cur-&gt;_parent;
        }
        return true;
    }
public:
    void _RotateL(Node*&amp; parent)
    {
        Node* subR = parent-&gt;_right;    //parent为_bf为2的节点,subR为_bf为1的节点
        Node* subRL = subR-&gt;_left;      //subRL为subR的左孩子

        parent-&gt;_right = subRL;         //将subRL链为parent的右孩子
        if (subRL)
            subRL-&gt;_parent = parent;

        subR-&gt;_parent = parent-&gt;_parent;//先将parent的父节点链为subR的父节点
        parent-&gt;_parent = subR;         //再将subR作为parent的父节点
        subR-&gt;_left = parent;

        parent-&gt;_bf = subR-&gt;_bf = 0;
        parent = subR;                  //将subR赋为parent(此处用的是引用,此处变,上面的cur也会变)

    }
    void _RotateR(Node*&amp; parent)
    {
        //右单旋与左单旋相似
        Node* subL = parent-&gt;_left;
        Node* subLR = subL-&gt;_right;

        parent-&gt;_left = subLR;
        if (subLR)
            subLR-&gt;_parent = parent;

        subL-&gt;_parent = parent-&gt;_parent;
        parent-&gt;_parent = subL;
        subL-&gt;_right = parent;

        parent-&gt;_bf = subL-&gt;_bf = 0;
        parent = subL;
    }
    void _RotateRL(Node*&amp; parent)
    {
        /*_RotateR(parent-&gt;_right);
        _RotateL(parent);*/
        Node* subR = parent-&gt;_right;
        Node* subRL = subR-&gt;_left;
        //右旋
        subR-&gt;_left = subRL-&gt;_right;
        if (subRL-&gt;_right)
            subRL-&gt;_right-&gt;_parent = subR;
        parent-&gt;_right = subRL;
        subRL-&gt;_right = subR;
        //改变平衡因子
        if (subRL-&gt;_bf == 0 || subRL-&gt;_bf == 1)
        {
            subR-&gt;_bf = 0;
        }
        else
        {
            subR-&gt;_bf = 1;
        }
        //左旋
        parent-&gt;_right = subRL-&gt;_left;
        if (subRL-&gt;_left)
            subRL-&gt;_left-&gt;_parent = parent;
        subRL-&gt;_parent = parent-&gt;_parent;
        subRL-&gt;_left = parent;
        parent-&gt;_parent = subRL;
        //改变平衡因子
        if (subRL-&gt;_bf == 0 || subRL-&gt;_bf == -1)
        {
            parent-&gt;_bf = 0;
        }
        else
        {
            parent-&gt;_bf = -1;
        }

        subRL-&gt;_bf = 0;
        parent = subRL;

    }
    void _RotateLR(Node*&amp; parent)
    {
        /*_RotateL(parent-&gt;_left);
        _RotateR(parent);*/
        Node* subL = parent-&gt;_left;
        Node* subLR = subL-&gt;_right;
        //左旋
        subL-&gt;_right = subLR-&gt;_left;
        if (subLR-&gt;_left)
            subLR-&gt;_left-&gt;_parent = subL;
        parent-&gt;_left = subLR;
        subLR-&gt;_left = subL;
        //改变平衡因子
        if (subLR-&gt;_bf == 0 || subLR-&gt;_bf == -1)
        {
            subL-&gt;_bf = 0;
        }
        else
        {
            subL-&gt;_bf = -1;
        }
        //右旋
        parent-&gt;_left = subLR-&gt;_right;
        if (subLR-&gt;_right)
            subLR-&gt;_right-&gt;_parent = parent;
        subLR-&gt;_parent = parent-&gt;_parent;
        subLR-&gt;_right = parent;
        parent-&gt;_parent = subLR;
        //改变平衡因子
        if (subLR-&gt;_bf == 0 || subLR-&gt;_bf == 1)
        {
            parent-&gt;_bf = 0;
        }
        else
        {
            parent-&gt;_bf = 1;
        }

        subLR-&gt;_bf = 0;
        parent = subLR;
    }
    int Hight()                   //求深度
    {
        return _Hight(_root);
    }
    bool IsBalance()              //判断是否平衡
    {
        return _IsBalance(_root);
    }
    void InOrder()
    {
        _InOrder(_root);
        cout &lt;&lt; endl;
    }
protected:
    void _InOrder(Node* root)
    {
        if (root == NULL)
            return;

        _InOrder(root-&gt;_left);
        cout &lt;&lt; root-&gt;_key &lt;&lt; &quot; &quot;;
        _InOrder(root-&gt;_right);
    }
    bool _IsBalance(Node* root)
    {
        if (root == NULL)
            return true;

        int left = _Hight(root-&gt;_left);
        int right = _Hight(root-&gt;_right);
        int poor = right-left;
        bool IsBalance = abs(poor) &lt; 2 &amp;&amp; root-&gt;_bf == poor;

        return _IsBalance(root-&gt;_left) &amp;&amp; _IsBalance(root-&gt;_right) &amp;&amp; IsBalance;
    }
    int _Hight(Node* root)
    {
        if (root == NULL)
            return 0;

        int left = _Hight(root-&gt;_left)+1;
        int right = _Hight(root-&gt;_right)+1;

        return left &gt; right ? left : right;
    }
protected:
    Node* _root;
};

void Test1()
{
    int a[] = { 16, 3, 7, 11, 9, 26, 18, 14, 15 };

    AVLTree&lt;int, int&gt; t;
    for (int i = 0; i &lt; sizeof(a) / sizeof(int);++i)
    {
        t.Insert(a[i],i);
    }

    t.InOrder();
    cout&lt;&lt;&quot;IsBalance:&quot;&lt;&lt;t.IsBalance()&lt;&lt;endl;
}

void Test2()
{
    int a[] = { 4, 2, 6, 1, 3, 5, 15, 7, 16, 14 };

    AVLTree&lt;int, int&gt; t;
    for (int i = 0; i &lt; sizeof(a) / sizeof(int); ++i)
    {
        t.Insert(a[i], i);
    }

    t.InOrder();
    cout &lt;&lt; &quot;IsBalance:&quot; &lt;&lt; t.IsBalance() &lt;&lt; endl;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/16/BinarySearchTree/" itemprop="url">
                  二叉搜索树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-04-16T14:17:13Z" content="2016-04-16">
              2016-04-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、二叉搜索树的性质：<br>1.每个节点都有一个作为搜索依据的关键码（key），所有节点的关键码互不相同。<br>2.左子树上所有节点的关键码（key）都小于根节点的关键码（key）。<br>3.右子树上所有节点的关键码（key）都大于根节点的关键码（key）。<br>4.左右子树都是二叉搜索树。</p>
<p>二、二叉搜索树的插入与删除<br>1.二叉搜索树的插入<br> 二叉搜索树的插入实现比较简单，比当前节点小就往左树找，比当前节点大就往右树找，直到找到空节点，然后链在该节点的父节点上即可。<br>2.二叉搜索树的删除<br> 这里我们重点讨论的是二叉搜索树的删除问题，我们通过一些图来进行讨论<br> <strong>在这之前我们需要知道的一点是二叉搜索树的任一节点的左子树上所有节点的关键码都小于该节点的关键码，而该节点的右子树上所有节点的关键码都大于该节点的关键码，所以二叉搜索树在进行中序遍历的时候得到的是一个有序且是升序的数列。</strong><br> 我们可以将要删除的节点分为以下三种情况:<br> 1.情况一:删除节点的左孩子为空:<br> <img src="http://o6lb63nu0.bkt.clouddn.com/searchtree1.png" alt="1"><br> 假设我们删除的是8这个节点cur，若删除了cur，那么要保证cur的父亲节点7(我们将其称为parent)这个节点新链的子树上所有节点的关键码要小于或大于parent的关键码，则显而易见parent要链接的新节点就是cur的右孩子(我们称之为child)(因为若cur是parent的左孩子，则以child这一节点为根节点的子树上所有节点的关键码一定小于parent的关键码，若为右孩子，则肯定大于parent的关键码)，这样删除左孩子为空的节点的思路就清晰了，将删除节点cur的右孩子child作为cur的父亲parent的孩子，然后删除cur，这样就完成了左孩子为空的节点的删除。<br> (删除节点9这样的的叶节点，我们可以把它归类到情况一或请况二中)<br> 2.情况二:删除节点的右孩子为空<br> <img src="http://o6lb63nu0.bkt.clouddn.com/searchtree2.png" alt="2"><br> 假设我们删除的是2这个节点cur，若删除了cur，那么要保证cur的父亲节点3(我们将其称为parent)这个节点新链的子树上所有节点的关键码要小于或大于parent的关键码，则显而易见parent要链接的新节点就是cur的左孩子(我们称之为child)(因为若cur是parent的左孩子，则以child这一节点为根节点的子树上所有节点的关键码一定小于parent的关键码，若为右孩子，则肯定大于parent的关键码)，这样删除右孩子为空的节点的思路就清晰了，将删除节点cur的左孩子child作为cur的父亲parent的孩子，然后删除cur，这样就完成了右孩子为空的节点的删除。<br> 3.情况三:删除节点左右孩子都不为空<br> <img src="http://o6lb63nu0.bkt.clouddn.com/searchtree3.png" alt="3"><br> 假设我们删除的是1这个节点cur，若删除cur，则要找一个新的节点(我们称为newnode)代替cur，并且满足newnode左子树上所有节点的关键码要比newnode的关键码小，其右子树上所有节点的关键码要比newnode的关键码大，在讨论这三种情况之前我们说过(上面的加粗部分)，二叉搜索树用中序遍历是有序的，那么我们只要找到cur中序遍历的下一个节点那么一定满足上述条件，要找到cur中序遍历的下一个节点也就是找cur的右子树中序遍历的第一个节点(我们称之为first)，那么剩下的事情就好办了，找到first节点，将其与cur节点交换，再将first节点删除就好了，因为first节点是cur右子树中序遍历的第一个节点，那么first节点一定满足左孩子为空这个条件，那么删除first节点同之前的情况一一样了。</p>
<p>三、二叉搜索树的代码实现<br>  在上面我们讨论了二叉搜索树一些操作的实现思路，接下来我们实现一下二叉搜索树的代码</p>
<pre><code>#pragma once

template&lt;class K, class V&gt;
//定义结构体，包含有左右孩子节点，关键字和与关键字有关的信息
//例如学生学号(关键字)和学生成绩(与关键字有关的信息)
struct BSTreeNode
{
    BSTreeNode&lt;K, V&gt;* _left;
    BSTreeNode&lt;K, V&gt;* _right;
    K _key;
    V _value;
    BSTreeNode(const K&amp; key, const V&amp; value)  //有参的构造函数
        :_left(NULL)
        , _right(NULL)
        , _key(key)
        , _value(value)
    {}
};

template&lt;class K, class V&gt;
class BSTree
{
    typedef BSTreeNode&lt;K, V&gt; Node;
public:
    BSTree()
        :_root(NULL)
    {}
public:
    bool InSert(const K&amp; key, const V&amp; value)
    {
        if (_root == NULL)
        {
            _root = new Node(key, value);     //刚插入是没有数据的情况，直接构造一个节点赋给根节点
        }
        else
        {
            Node* cur = _root;                //cur指向根节点
            Node* prev = NULL;                //prev指向cur的父节点，初始化为空
            while (cur)                       //找要插入节点的位置
            {
                if (cur-&gt;_key &lt; key)          //比该节点大在该节点的右子树上找
                {
                    prev = cur;
                    cur = cur-&gt;_right;
                }
                else if (cur-&gt;_key &gt; key)     //比该节点小在该节点的左子树上找
                {
                    prev = cur;
                    cur = cur-&gt;_left;
                }
                else                          //与该节点相等时插入失败
                {
                    return false;
                }
            }
            Node* newnode = new Node(key, value); //构造新节点并插入相应的位置
            if (prev-&gt;_key &lt; key)
                prev-&gt;_right = newnode;
            else
                prev-&gt;_left = newnode;
        }
        return true;
    }
    bool InSert_R(const K&amp; key, const V&amp; value)   //使用递归插入节点
    {
        return _InSert_R(_root, key, value);
    }
    bool Remove(const K&amp; key, const V&amp; value)
    {
        if (_root == NULL)
            return false;
        Node* cur = _root;
        Node* prev = NULL;
        while (cur)
        {
            if (cur-&gt;_key &lt; key)                //先找到要删除的节点
            {
                prev = cur;
                cur = cur-&gt;_right;
            }
            else if (cur-&gt;_key &gt; key)
            {
                prev = cur;
                cur = cur-&gt;_left;
            }
            else
            {
                if (cur-&gt;_left == NULL)        //如果要删除节点cur的左孩子为空
                {                              //该节点cur的父节点prev指向cur的右孩子
                    if (prev-&gt;_left == cur)
                        prev-&gt;_left = cur-&gt;_right;
                    else
                        prev-&gt;_right = cur-&gt;_right;
                    delete cur;                //删除节点
                }
                else if (cur-&gt;_right == NULL)  //如果要删除节点cur的右孩子为空
                {                              //该节点cur的父节点prev指向cur的左孩子
                    if (prev-&gt;_left == cur)
                        prev-&gt;_left = cur-&gt;_right;
                    else
                        prev-&gt;_right = cur-&gt;_right;
                    delete cur;                //删除节点
                }
                else                           //如果该节点cur的左右孩子都不为空
                {                              //找到cur中序遍历的下一个节点(分两种情况)
                    Node* next = cur-&gt;_right;
                    prev = next;
                    if (next-&gt;_left == NULL)   //case1:cur右孩子的左孩子为空
                    {                          //将cur与cur的右孩子交换
                        swap(cur-&gt;_key, next-&gt;_key);
                        swap(cur-&gt;_value, next-&gt;_value);
                        cur-&gt;_right = next-&gt;_right; //将cur的右孩子指向cur右孩子的右孩子
                        delete next;           //删除cur的右孩子
                    }
                    else                       //case2:cur右孩子的左孩子不为空
                    {                          //循环找到cur中序遍历的下一个节点next
                        while (next-&gt;_left)
                        {
                            prev = next;
                            next = next-&gt;_left;
                        }
                        swap(cur-&gt;_key, next-&gt;_key); //交换cur与next
                        swap(cur-&gt;_value, next-&gt;_value);
                        prev-&gt;_left = next-&gt;_right;  //将next的右孩子作为next父节点的左孩子
                        delete next;                 //删除next
                    }
                }
            }
        }
        return false;
    }
    bool Remove_R(const K&amp; key, const V&amp; value)      //递归实现删除节点
    {
        if (_root == NULL)
            return false;
        return _Remove_R(_root, key, value);
    }
    Node* Find(const K&amp; key, const V&amp; value)        //寻找指定的节点
    {
        Node* cur = _root;
        while (cur)
        {
            if (cur-&gt;_key &lt; key)
                cur = cur-&gt;_right;
            else if (cur-&gt;_key &gt; key)
                cur = cur-&gt;_left;
            else
                return cur;
        }
        return NULL;
    }
    Node* Find_R(const K&amp; key, const V&amp; value)      //递归寻找指定的节点
    {
        return _Find_R(_root, key);
    }
    void InOrder()
    {
        _InOrder(_root);
        cout &lt;&lt; endl;
    }
protected:
    void _InOrder(Node* root)
    {
        Node* node = root;
        if (node == NULL)
            return;
        _InOrder(node-&gt;_left);
        cout &lt;&lt; node-&gt;_key &lt;&lt; &quot;-&gt;&quot; &lt;&lt; node-&gt;_value &lt;&lt; &quot; &quot;;
        _InOrder(node-&gt;_right);
    }
    Node* _Find_R(Node* root, const K&amp; key)
    {
        if (root == NULL)
            return NULL;
        if (root-&gt;_key &lt; key)
            return _Find_R(root-&gt;_right, key);
        else if (root-&gt;_key &gt; key)
            return _Find_R(root-&gt;_left, key);
        else
            return root;
    }
    bool _Remove_R(Node*&amp; root, const K&amp; key, const V&amp; value)
    {
        if (root-&gt;_key &lt; key)
            return _Remove_R(root-&gt;_right, key, value);
        else if (root-&gt;_key &gt; key)
            return _Remove_R(root-&gt;_left, key, value);
        else
        {
            Node* cur = root;
            if (cur-&gt;_left == NULL)
            {
                root = cur-&gt;_right;
                delete cur;
            }
            else if (cur-&gt;_right == NULL)
            {
                root = cur-&gt;_left;
                delete cur;
            }
            else
            {
                Node* next = cur-&gt;_right;
                if (next-&gt;_left == NULL)
                {
                    cur-&gt;_key = next-&gt;_key;
                    cur-&gt;_value = next-&gt;_value;
                    cur-&gt;_right = next-&gt;_right;
                    delete next;
                }
                else
                {
                    Node* prev = NULL;
                    while (next-&gt;_left)
                    {
                        prev = next;
                        next = next-&gt;_left;
                    }
                    cur-&gt;_key = next-&gt;_key;
                    cur-&gt;_value = next-&gt;_value;
                    prev-&gt;_left = next-&gt;_right;
                    delete next;
                }
            }
            return true;
        }
        return false;
    }
    bool _InSert_R(Node*&amp; root, const K&amp; key, const V&amp; value)
    {
        if (root == NULL)
        {
            Node* newnode = new Node(key, value);
            root = newnode;              //这里使用的是引用，root改变
            return true;                 //则上一层的root-&gt;_left或root-&gt;_right也改变
        }
        if (root-&gt;_key &lt; key)
            return _InSert_R(root-&gt;_right, key, value);
        else if (root-&gt;_key &gt; key)
            return _InSert_R(root-&gt;_left, key, value);
        else
            return false;
    }
protected:
    Node* _root;
};
void Test()
{
    BSTree&lt;int, int&gt; t;
    int a[] = { 5, 3, 4, 1, 7, 8, 2, 6, 0, 9 };
    for (int i = 0; i &lt; sizeof(a) / sizeof(int); ++i)
    {
        //t.InSert(a[i], a[i]);
        t.InSert_R(a[i], a[i]);
    }

    t.Remove(5, 5);
    t.InOrder();
    t.Remove_R(7, 7);
    t.InOrder();

    BSTreeNode&lt;int, int&gt;* node = t.Find(6, 6);
    cout &lt;&lt; node-&gt;_key &lt;&lt; &quot;-&gt;&quot; &lt;&lt; node-&gt;_value &lt;&lt; endl;
    node = t.Find_R(10, 10);
    t.InOrder();
}
</code></pre><p>普通的二叉搜索树在一般情况下可以提高查找数据的效率，但当插入的数据是有序的情况下，这种普通的二叉搜索树会退化成类似单链表的形式，因此，就有了我们下一篇要说的二叉平衡搜索树。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/12/BinaryTree/" itemprop="url">
                  二叉树
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-04-11T18:56:35Z" content="2016-04-11">
              2016-04-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、一个树包含以下几个部分<br>  结点：结点包含数据和指向其它结点的指针。<br>  根节点：树第一个结点称为根节点。<br>  结点的度：结点拥有的子节点个数。<br>  叶节点：没有子节点的节点(度为0)。<br>  父子节点：一个节点father指向另一个节点child，则child为孩子节点，father为父亲结点。<br>  兄弟节点：具有相同父节点的节点互为兄弟节点。<br>  节点的祖先：从根节点开始到该节点所经的所有节点都可以称为该节点的祖先。<br>  子孙：以某节点为根的子树中任一节点都称为该节点的子孙。<br>  树的高度：树中距离根节点最远结点的路径长度。<br>  如图1:<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/binarytree1.png" alt="1"><br>  *但树不能有连通的情况<br>  例如:<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/binarytree2.png" alt="2"><br>  如上图2所示的就不是一个树</p>
<p>  而一个树的存储结构是如图3:<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/binarytree3.png" alt="3"></p>
<p>二、二叉树<br>  二叉树:二叉树是一棵特殊的树，二叉树每个节点最多有两个孩子结点，分别称为左孩子和右孩子。<br>  满二叉树:高度为N的满二叉树有2^N - 1个节点的二叉树。<br>  完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个<br>  数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。<br>  如图4、图5:<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/binarytree4.png" alt="4"><br>  <img src="http://o6lb63nu0.bkt.clouddn.com/binarytree5.png" alt="5"></p>
<p>三、二叉树的遍历方法<br>  <img src="http://o6lb63nu0.bkt.clouddn.com/binarytree6.png" alt="6"><br>  前序遍历(先根遍历):(1)：先访问根节点；(2)：前序访问左子树；(3)：前序访问右子树。<br> 【1 2 3 4 5 6】<br>  中序遍历:(1)：中序访问左子树；(2)：访问根节点；(3)：中序访问右子树。<br> 【3 2 4 1 6 5】<br>  后序遍历(后根遍历):(1)：后序访问左子树；(2)：后序访问右子树；(3)：访问根节点。<br> 【3 4 2 6 5 1】<br>  层序遍历：一层层节点依次遍历。<br> 【1 2 5 3 4 6】</p>
<p>四、二叉树的代码实现<br>  只是进行概念的讲解的话难免会有些枯燥，下面是我实现的代码，中间也有注释进行说明。</p>
<pre><code>#pragma once
#include&lt;assert.h&gt;
#include&lt;queue&gt;

template&lt;class T&gt;
struct BinaryTreeNode                   //二叉树结构
{
    T _data;
    BinaryTreeNode&lt;T&gt;* _left;
    BinaryTreeNode&lt;T&gt;* _right;
    BinaryTreeNode(const T&amp; x)         //节点的构造函数
        :_data(x)
        , _left(NULL)
        , _right(NULL)
    {
    }
};

template&lt;class T&gt;
class BinaryTree
{
public:
    BinaryTree()                       //无参的构造函数
        :_root(NULL)
    {
    }
    BinaryTree(const T* a,size_t size) //有参的构造函数
    {
        size_t index = 0;
        _root = CreateTree(a,size,index);
    }
    void PrevOrder()                  //先序遍历
    {
        _PrevOrder(_root);
        cout &lt;&lt; endl;
    }
    void InOrder()                    //中序遍历
    {
        _InOrder(_root);
        cout &lt;&lt; endl;
    }
    void PostOrder()                  //后序遍历
    {
        _PostOrder(_root);
        cout &lt;&lt; endl;
    }
    void LevelOrder()                 //层次遍历(通过队列来实现)
    {
        queue&lt;BinaryTreeNode&lt;T&gt;*&gt; q;
        if (_root == NULL)
        {
            return;
        }
        q.push(_root);
        while (!q.empty())
        {
            BinaryTreeNode&lt;T&gt;* root = q.front();
            q.pop();
            if (root-&gt;_left)          //如果出队的节点的左孩子或右孩子不为空,其不为空的孩子入队列 
            {
                q.push(root-&gt;_left);
            }
            if (root-&gt;_right)
            {
                q.push(root-&gt;_right);
            }
            cout &lt;&lt; root-&gt;_data &lt;&lt; &quot; &quot;;//打印出队的节点-&gt;相当于遍历出队的节点
        }
        cout &lt;&lt; endl;
    }
    size_t Size()
    { 
        return _Size(_root);
    }
    size_t Depth()                    //计算二叉树的深度
    {
        return _Depth(_root);
    }
    BinaryTreeNode&lt;T&gt;* Find(const T&amp; x)//用层次遍历寻找符合条件的节点
    {
        queue&lt;BinaryTreeNode&lt;T&gt;*&gt; q;
        if (_root == NULL)
        {
            return NULL;
        }
        q.push(_root);
        while (!q.empty())
        {
            BinaryTreeNode&lt;T&gt;* root = q.front();
            q.pop();
            if (root-&gt;_left)
            {
                q.push(root-&gt;_left);
            }
            if (root-&gt;_right)
            {
                q.push(root-&gt;_right);
            }
            if (root-&gt;_data == x)
            {
                return root;
            }
        }
        return NULL;
        cout &lt;&lt; endl;
    }
protected:
    size_t _Depth(BinaryTreeNode&lt;T&gt;* root)
    {
        if (root == NULL)
        {
            return 0;
        }
        size_t leftdepth = 1;
        size_t rightdepth = 1;
        leftdepth += _Depth(root-&gt;_left);
        rightdepth += _Depth(root-&gt;_right);
        return (leftdepth &gt; rightdepth) ? leftdepth : rightdepth;
    }
    size_t _Size(BinaryTreeNode&lt;T&gt;* root)
    {
        if (root == NULL)
            return 0;
        return (_Size(root-&gt;_left) + _Size(root-&gt;_right) + 1);
    }
    void _PostOrder(BinaryTreeNode&lt;T&gt;* root)
    {
        BinaryTreeNode&lt;T&gt;* curroot = root;
        if (curroot == NULL)
        {
            return;
        }
        _PostOrder(curroot-&gt;_left);    
        _PostOrder(curroot-&gt;_right);
        cout &lt;&lt; curroot-&gt;_data &lt;&lt; &quot; &quot;;
    }
    void _InOrder(BinaryTreeNode&lt;T&gt;* root)
    {
        BinaryTreeNode&lt;T&gt;* curroot = root;
        if (curroot == NULL)
        {
            return;
        }
        _InOrder(curroot-&gt;_left);
        cout &lt;&lt; curroot-&gt;_data &lt;&lt; &quot; &quot;;
        _InOrder(curroot-&gt;_right);
    }
    void _PrevOrder(BinaryTreeNode&lt;T&gt;* root)
    {
        BinaryTreeNode&lt;T&gt;* curroot = root;
        if (curroot == NULL)
        {
            return;
        }
        cout &lt;&lt; curroot-&gt;_data &lt;&lt; &quot; &quot;;
        _PrevOrder(curroot-&gt;_left);
        _PrevOrder(curroot-&gt;_right);
    }
    //建立二叉树(index为数组下标)
    BinaryTreeNode&lt;T&gt;* CreateTree(const T*a,size_t size,size_t&amp; index)
    {
        assert(a);
        BinaryTreeNode&lt;T&gt;* newroot = NULL;
        if (index &lt; size &amp;&amp; a[index] != &apos;#&apos;)
        {
            newroot = new BinaryTreeNode&lt;T&gt;(a[index]);
            newroot-&gt;_left = CreateTree(a, size, ++index);
            newroot-&gt;_right = CreateTree(a, size, ++index);
        }
        return newroot;
    }
protected:
    BinaryTreeNode&lt;T&gt;* _root;
};

void Test()
{
    int a[10] = {1,2,3,&apos;#&apos;,&apos;#&apos;,4,&apos;#&apos;,&apos;#&apos;,5,6};
    BinaryTree&lt;int&gt; t1(a,10);
    t1.PrevOrder();
    t1.InOrder();
    t1.PostOrder();
    t1.LevelOrder();
    cout &lt;&lt; t1.Size() &lt;&lt; endl;
    cout &lt;&lt; t1.Depth() &lt;&lt; endl;
    cout &lt;&lt; t1.Find(3)-&gt;_data &lt;&lt; endl;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/07/my-first-blog/" itemprop="url">
                  哈希表与哈希冲突
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-04-07T15:58:15Z" content="2016-04-07">
              2016-04-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、什么是哈希表？<br> 哈希表是根据关键字（key）而直接访问在内存存储位置的数据结构。它通过一个关键值的函数将所需的数据映射到表中的位置来访问数据，这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p>二、什么是哈希冲突？<br> 不同的Key值经过哈希函数Hash(Key)处理以后可能产生相同的值——哈希地址，我们称这种情况为哈希冲突。任意的散列函数都不能避免产生冲突。<br>**何为荷载因子:荷载因子 = 填入表中的元素个数/散列表的长度<br> 因为散列表的长度为定值，所以当荷载因子越大时，表中元素就越多则产生冲突的可能性越大，所以荷载因子一般被限定在0.7-0.8。</p>
<p>三、解决哈希冲突的办法：<br>1、闭散列法<br>(1)线性探测<br>描述：线性探测是解决哈希冲突的一种方法，key值经过哈希函数处理就会得到对应的哈希地址，当这个地址已经存放了其他的key值时，向后寻找该地址的下一个地址，如果仍有其他的key值那么接着向后找，直到找到空闲的位置为止。<br><img src="http://o6lb63nu0.bkt.clouddn.com/Hash1.png" alt="1"><br>线性探测的代码实现</p>
<pre><code>#pragma once
#include&lt;string&gt;

enum Status        //使用状态机来表示散列表每个位置的状态
{                 
    EXITS,         //存在
    DELETED,       //删除
    EMPTY,         //空
};

template&lt;class T&gt;                      //使用仿函数获得不同类型关键字的哈希值
struct HashFuner
{
    size_t operator()(const T&amp; key)
    {
        return key;
    }
};

static size_t BKDRHash(const char* str)//字符串的哈希算法
{
    size_t seed = 131;
    size_t hash = 0;
    while (*str)
    {
        hash = hash * seed + (*str++);
    }
    return (hash &amp; 0x7FFFFFFF);
}

template&lt;&gt;
struct HashFuner&lt;string&gt;               //获得string类型的哈希值
{
    size_t operator()(const string&amp; key)
    {
        return BKDRHash(key.c_str());    
    }    
};


template&lt;class T,class HashFun = HashFuner&lt;T&gt;&gt;
class HashTable
{
public:
    HashTable()                        //无参的构造函数
        :_array(NULL)
        , _status(0)
        , _size(0)
        , _capacity(0)
    {}
    HashTable(const size_t size)       //有参的构造函数
        :_array(new T[size])
        , _status(new Status[size])
        , _size(0)
        , _capacity(size)
    {
        for (size_t i = 0; i &lt; size;++i)
        {
            _status[i] = EMPTY;       //初始状态全部置为空
        }
    }
    ~HashTable()                      //析构函数
    {
        if (_array)
        {
            delete[] _array;
            delete[] _status;
        }
    }
public:
    bool Insert(const T&amp; key)
    {
        if (_size*10/_capacity == 8)     //荷载因子一般控制在0.7到0.8之间，当荷载因子达到0.8时需要增容
        {
            HashTable&lt;T,HashFun&gt; newHT(_capacity * 2); //开辟一个更长长度的新空间
            for (size_t i = 0; i &lt; _capacity;++i)
            {
                if (_status[i] == EXITS)
                {
                    newHT.Insert(_array[i]);           //将原有空间里的所有数据插入到新的空间
                }
            }
            Swap(newHT);                               //与原有空间交换
        }
        size_t index = Location(key);                  //获取关键字的位置
        while (_status[index] == EXITS)                //如果该位置已有数据则向后寻找
        {
            ++index;
            if (index == _capacity)                    //若已经走到表的尾部，则回到表头
            {
                index = 0;
            }    
        }
        _array[index] = key;                           //插入数据
        _status[index] = EXITS;                        //状态置为存在状态
        ++_size;                                       //表中数据个数加一
        return true;
    }
    size_t Location(const T&amp; key)                      //得到关键字的位置
    {
        HashFun hash;                                  //用仿函数获取不同类型关键字的哈希值
        return hash(key)%_capacity;                    //计算得到关键字的位置
    }
    bool Remove(const T&amp; key)
    {
        size_t index = Location(key);                  //找到关键字的起始位置
        while (_status[index] != EMPTY)                //如果位置不为空则寻找
        {
            if (_array[index] == key &amp;&amp; _status[index] == EXITS)
                                                       //若该位置的关键字与要找的关键字相同并且状态为存在，说明已找到，
                                                       //状态置为删除状态，并且数据个数减一(若状态为删除状态则表示已经删除)
            {
                _status[index] = DELETED;
                _size--;
            }
            ++index;                                   //否则的话向后继续寻找
            if (index == _capacity)
            {
                index = 0;
            }
        }
        return false;
    }
    size_t Find(const T&amp; key)
    {
        size_t index = Location(key);                  //获得关键字的初始位置
        while (_status[index] != EMPTY)                //如果位置不为空则寻找
        {
            if (_array[index] == key &amp;&amp; _status[index] == EXITS)
                                                       //如果该关键字与要找的关键字相同且状态为存在，则返回位置
                                                       //(若状态为删除状态则表示已经删除)
            {
                return index;
            }
            ++index;                                   //否则的话继续向后寻找
            if (index == _capacity)
            {
                index = 0;
            }
        }
        return -1;
    }
    void Print()
    {
        for (size_t i = 0; i &lt; _capacity;++i)
        {
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _array[i] &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _status[i] &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;----------------------------------&quot;&lt;&lt;endl;
    }
    void PrintStr()
    {
        for (size_t i = 0; i &lt; _capacity; ++i)
        {
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _array[i].c_str() &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _status[i] &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;
    }
protected:
    void Swap(HashTable&lt;T,HashFun&gt;&amp; ht)                //交换函数，用于扩容后两个空间的交换
    {
        swap(ht._array,_array);
        swap(ht._status,_status);
        swap(ht._size,_size);
        swap(ht._capacity,_capacity);
    }
protected:
    T* _array;              //散列表
    Status* _status;        //状态机
    size_t _size;           //数据个数
    size_t _capacity;       //删列表长度
};

void TestLiner()
{
    HashTable&lt;int&gt; h1(10);
    h1.Insert(89);
    h1.Insert(19);
    h1.Insert(49);
    h1.Insert(18);
    h1.Insert(9);
    h1.Insert(89);
    h1.Insert(19);
    h1.Insert(49);
    h1.Insert(18); 
    h1.Insert(9);

    h1.Print();

    h1.Remove(9);
    h1.Remove(29);

    h1.Print();

    size_t pos = h1.Find(18);
    cout &lt;&lt; &quot;Find():&quot; &lt;&lt; pos &lt;&lt; endl;

    HashTable&lt;string&gt; h2(5);
    h2.Insert(&quot;abcd&quot;);
    h2.Insert(&quot;dbca&quot;);

    h2.PrintStr();
}
</code></pre><p>不难看出，线性探测解决哈希冲突的效率并不理想，尤其是当数据比较多的时候由此我们就可以接着来进行讨论线性探测的优化算法——二次探测。<br>(2)二次探测<br>描述：二次探测是线性探测的优化算法，在线性探测的基础上，查找方式略有不同线性探测在遇到对应的哈希地址有其他key值的情况下，查找的下一个地址用函数Hash(key)+n^2(n&gt;=0)进行查找，这样使得查找起来比线性探测更加的高效，但这样仍然不是很优化，所以接下来我们推出开链法，也就是俗称的哈希桶。<br><img src="http://o6lb63nu0.bkt.clouddn.com/Hash2.png" alt="2"><br>二次探测的代码实现<br>    //二次探测的实现与线性探测大致相同，只有一些细微的差别</p>
<pre><code>#pragma once
#include&lt;string&gt;

enum Status
{
    EXITS,
    DELETED,
    EMPTY,
};

template&lt;class K&gt;
struct HashFuner
{
    size_t operator()(const K&amp; key)
    {
        return key;
    }
};

static size_t BKDRHash(const char* str)
{
    size_t seed = 131;
    size_t hash = 0;
    while (*str)
    {
        hash = hash * seed + (*str++);
    }
    return (hash &amp; 0x7FFFFFFF);
}

template&lt;&gt;
struct HashFuner&lt;string&gt;
{
    size_t operator()(const string&amp; key)
    {
        return BKDRHash(key.c_str());
    }
};

template&lt;class K, class V&gt;
struct KeyValueNode               //定义结构体包含关键字和与关键字有关的信息
{                                 //例如学生的学号(关键字)与成绩(与关键字有关的信息)
    K key;
    V value;
    KeyValueNode()
    {}
    KeyValueNode(const K&amp; key, const V&amp; value)
       :key(key)
       ,value(value)
    {}
};

template&lt;class K, class V, class HashFun = HashFuner&lt;K&gt;&gt;
class HashTable
{
    typedef KeyValueNode&lt;K, V&gt; KVNode;
public:
    HashTable()
        :_array(NULL)
        , _status(0)
        , _size(0)
        , _capacity(0)
    {}
    HashTable(const size_t size)
        :_array(new KVNode[size])
        , _status(new Status[size])
        , _size(0)
        , _capacity(size)
    {
        for (size_t i = 0; i &lt; size; ++i)
        {
            _status[i] = EMPTY;
        }
    }
    ~HashTable()
    {
        if (_array)
        {
            delete[] _array;
            delete[] _status;
        }
    }
    HashTable(const HashTable&lt;K,V&gt;&amp; ht)
    {
        HashTable&lt;K, V&gt; newHT(ht._capacity);
        for (size_t i = 0; i &lt; ht._capacity; ++i)
        {
            if (ht._status[i] == EXITS)
            {
                newHT.Insert(ht._array[i].key, ht._array[i].value);
            }
        }
        Swap(newHT);
    }
    HashTable&lt;K, V&gt;&amp; operator=(const HashTable&lt;K, V&gt;&amp; ht)
    {
        HashTable&lt;K, V&gt; newTable(ht);
        Swap(newTable);
        return *this;
    }
public:
    bool Insert(const K&amp; key,const V&amp; value)
    {
        if (_size * 10 / _capacity == 8)
        {
            HashTable&lt;K, V&gt; newHT(_capacity * 2);
            for (size_t i = 0; i &lt; _capacity; ++i)
            {
                if (_status[i] == EXITS)
                {
                    newHT.Insert(_array[i].key, _array[i].value);
                }
            }
            Swap(newHT);
        }
        size_t index = Location0(key);
        size_t i = 1;
        while (_status[index] == EXITS)
        {
            index = Location2(index,i++);
            if (index == _capacity)
            {
                index = 0;
            }
        }
        _array[index].key = key;
        _array[index].value = value;
        _status[index] = EXITS;
        ++_size;
        return true;
    }
    size_t Location0(const K&amp; key)              //求取的是关键字的初始地址
    {
        HashFun hash;
        return hash(key) % _capacity;
    }
    size_t Location2(size_t prev,size_t i)      //查找下一个地址用函数Hash(key)+n^2(n&gt;=0)进行查找
    {                                           //通过化简得到前一个位置的哈希值与后一个位置的哈希值的关系
        return (prev + 2 * i - 1) % _capacity;  //后一位置的哈希值为前一个位置哈希值的二倍减一
    }
    bool Remove(const K&amp; key,size_t n)
    {
        size_t index = Location0(key);
        size_t i = 1;
        while (_status[index] != EMPTY)
        {
            if (_array[index].key == key &amp;&amp; _status[index] == EXITS)
            {
                _status[index] = DELETED;
                _size--;
            }
            index = Location2(index, i++);
            if (index == _capacity)
            {
                index = 0;
            }
        }
        return false;
    }
    size_t Find(const K&amp; key, size_t n)
    {
        size_t index = Location(key);
        size_t i = 1;
        while (_status[index] != EMPTY)
        {
            if (_array[index].key == key &amp;&amp; _status[index] == EXITS)
            {
                return index;
            }
            index = Location2(index, i++);
            if (index == _capacity)
            {
                index = 0;
            }
        }
        return -1;
    }
    void Print()
    {
        for (size_t i = 0; i &lt; _capacity; ++i)
        {
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _array[i].key &lt;&lt; &quot;-&quot;;
            cout &lt;&lt; _array[i].value &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _status[i] &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;
    }
    void PrintStr()
    {
        for (size_t i = 0; i &lt; _capacity; ++i)
        {
            cout &lt;&lt; &quot;[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _array[i].key.c_str() &lt;&lt; &quot;-&quot;;
            cout &lt;&lt; _array[i].value.c_str() &lt;&lt; &quot;:&quot;;
            cout &lt;&lt; _status[i] &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;----------------------------------&quot; &lt;&lt; endl;
    }
protected:
    void Swap(HashTable&lt;K,V&gt;&amp; ht)
    {
        swap(ht._array, _array);
        swap(ht._status, _status);
        swap(ht._size, _size);
        swap(ht._capacity, _capacity);
    }
protected:
    KVNode* _array;
    Status* _status;
    size_t _size;
    size_t _capacity;
};

void TestTwice()
{
    HashTable&lt;int, int&gt; ht(5);
    ht.Insert(12,14);
    ht.Insert(11,50);
    ht.Insert(24,22);
    ht.Insert(1,18);
    ht.Insert(4,55);
    ht.Print();

    HashTable&lt;int, int&gt; ht1(ht);
    ht1.Print();

    HashTable&lt;int, int&gt; ht2;
    ht2 = ht;
    ht2.Print();

    HashTable&lt;string, string&gt; htstr(10);
    htstr.Insert(&quot;字典&quot;, &quot;dictionary&quot;);
    htstr.Insert(&quot;清除&quot;, &quot;clear,destroy&quot;);
    htstr.Insert(&quot;手机&quot;, &quot;mobilephone&quot;);
    htstr.Insert(&quot;电脑&quot;, &quot;pc&quot;);
    htstr.Insert(&quot;吸血鬼&quot;, &quot;vampire&quot;);
    htstr.PrintStr();

    HashTable&lt;string, string&gt; htstr1(htstr);
    htstr1.PrintStr();
}
</code></pre><p>2、开链法(哈希桶)<br>描述：开链法使用的是单链表与顺序表相结合的算法，顺序表的每一个位置链接的的是相应key值对应的单链表的头结点，那么当某个key值找到对应的哈希地址时，将该key值插入到该链表中(我实现时用的是头插)，这样建立起来的散列表无论是存储key值还是查找key值，相比起闭散列法中的两种方法都比较高效。<br><img src="http://o6lb63nu0.bkt.clouddn.com/Hash3.png" alt="3"><br>开链法的代码实现</p>
<pre><code>开链法与闭散列法的区别在于散列表的每一个位置存放的不是数据，而是每个位置都链有一个单链表，而当出现
哈希冲突时不用再先后寻找空位置，而是直接将该数据头插到对应位置的单链表中。
#pragma once
#include&lt;vector&gt;
#include&lt;string&gt;

template&lt;class K&gt;
struct HashFuner
{
    size_t operator()(const K&amp; key)
    {
        return key;
    }
};

static size_t BKDRHash(const char* str)
{
    size_t seed = 131;
    size_t hash = 0;
    while (*str)
    {
        hash = hash * seed + (*str++);
    }
    return (hash &amp; 0x7FFFFFFF);
}

template&lt;&gt;
struct HashFuner&lt;string&gt;
{
    size_t operator()(const string&amp; key)
    {
        return BKDRHash(key.c_str());
    }
};

template&lt;class K,class V&gt;
struct HashTableNode
{
    K _key;
    V _value;
    HashTableNode&lt;K,V&gt;* _next;
    HashTableNode(const K&amp; key, const V&amp; value)
        :_key(key)
        , _value(value)
        , _next(NULL)
    {}
};

template&lt;class K, class V, class HashFun = HashFuner&lt;K&gt;&gt;
class HashTable
{
public:
    typedef HashTableNode&lt;K, V&gt; KVNode;
public:
    HashTable()
        :_size(0)
    {}
    HashTable(size_t size)
    {
        _tables.resize(size);
    }
    ~HashTable()
    {
        Destroy();
    }
    HashTable(const HashTable&lt;K, V&gt;&amp; ht)
    {
        HashTable&lt;K, V&gt; newTable(ht._tables.size());     
        for (size_t i = 0; i &lt; ht._tables.size();++i)
        {
            //KVNode* &amp; head = newTable._tables[i];
            KVNode* cur = ht._tables[i];
            if (cur == NULL)
            {
                continue;
            }
            while (cur)
            {
                /*KVNode* tmp = cur;
                cur = cur-&gt;_next;
                tmp-&gt;_next = head;
                head = tmp;*/
                newTable.Insert(cur-&gt;_key,cur-&gt;_value);
                cur = cur-&gt;_next;
            }

        }
        Swap(newTable);
    }
    HashTable&lt;K, V&gt;&amp; operator=(const HashTable&lt;K, V&gt;&amp; ht)
    {
        if (&amp;ht != this)
        {
            HashTable&lt;K, V&gt; newTable(ht);
            Swap(newTable);
        }
        return *this;
    }
public:
    bool Insert(const K&amp; key,const V&amp; value)
    {
        //增容
        _CreateCapacity();
        //插入数据
        size_t index = Location(key);
        KVNode* cur = new KVNode(key,value);
        if (_tables[index] == NULL)
        {
            cur-&gt;_next = _tables[index];
            _tables[index] = cur;
            ++_size;
        }
        else
        {
            KVNode* tmp = _tables[index];
            while (tmp)
            {
                if (tmp-&gt;_key == key)
                    return false;
                tmp = tmp-&gt;_next;
            }
            cur-&gt;_next = _tables[index];
            _tables[index] = cur;
        }
        return true;
    }
    size_t Location(const K&amp; key)
    {
        HashFuner&lt;K&gt; hf;
        return hf(key) % _tables.size();
    }
    void Print()
    {
        for (size_t i = 0; i &lt; _tables.size();++i)
        {
            printf(&quot;Table[%d]-&gt;&quot;, i);
            KVNode* cur = _tables[i];
            while (cur)
            {
                cout &lt;&lt; &quot;[&quot; &lt;&lt; cur-&gt;_key &lt;&lt; &quot;:&quot; &lt;&lt; cur-&gt;_value &lt;&lt; &quot;]-&gt;&quot;;
                cur = cur-&gt;_next;
            }
            cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;-------------------------------------&quot; &lt;&lt; endl;
    }
    bool Remove(const K&amp; key)
    {
        size_t index = Location(key);
        KVNode* cur = _tables[index];
        if (cur == NULL)
        {
            return true;
        }
        if (cur-&gt;_next == NULL)
        {
            delete cur;
            _tables[index] = NULL;
            return true;
        }
        while (cur)
        {
            KVNode* prev = cur;
            KVNode* tmp = cur-&gt;_next;
            if (tmp-&gt;_key == key)
            {
                prev-&gt;_next = tmp-&gt;_next;
                delete tmp;
                return true;
            }
            cur = cur-&gt;_next;
        }
        return false;
    }
    KVNode* Find(const K&amp; key)
    {
        size_t index = Location(key);
        KVNode* cur = _tables[index];
        while (cur)
        {
            if (cur-&gt;_key == key)
            {
                return cur;
            }
            cur = cur-&gt;_next;
        }
        return NULL;
    }
protected:
    void Swap(HashTable&lt;K,V&gt;&amp; ht)
    {
        _tables.swap(ht._tables);
        swap(_size,ht._size);
    }
    void Destroy()
    {
        for (size_t i = 0; i &lt; _tables.size(); ++i)
        {
            KVNode* cur = _tables[i];
            while (cur)
            {
                KVNode* tmp = cur;
                cur = cur-&gt;_next;
                delete tmp;
            }
            _tables[i] = NULL;
        }
    }
    void _CreateCapacity()                        //这里的设置散列表的容量时使用一个数组给定的容量值
    {
        static const int _PrimeSize = 28;
        static const unsigned long _PrimeList[_PrimeSize] =
        {
            53ul, 97ul, 193ul, 389ul, 769ul,
            1543ul, 3079ul, 6151ul, 12289ul, 24593ul,
            49157ul, 98317ul, 196613ul, 393241ul, 786433ul,
            1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul,
            50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul,
            1610612741ul, 3221225473ul, 4294967291ul
        };
        if (_size == _tables.size())
        {
            HashTable&lt;K,V&gt; ht;
            for (int i = 0; i &lt; _PrimeSize;++i)
            {
                if (_size &lt; _PrimeList[i])
                {
                    ht._tables.resize(_PrimeList[i]);
                    break;
                }        
            }
            for (size_t i = 0; i &lt; _size;++i)
            {
                KVNode* cur = _tables[i];
                while (cur)
                {    
                    ht.Insert(cur-&gt;_key, cur-&gt;_value);
                    cur = cur-&gt;_next;
                }
            }
            _tables.swap(ht._tables);
        }
    }
protected:
    vector&lt;KVNode*&gt; _tables;
    size_t _size;
};

void TestBucket()
{
    HashTable&lt;int,int&gt; ht(2);
    ht.Insert(1,25);
    ht.Insert(11, 35);
    ht.Insert(12, 21);
    ht.Insert(16, 36);
    ht.Insert(19, 81);
    ht.Insert(54, 0);
    //ht.Print();

    //ht.Remove(12);
    //ht.Print();

    //HashTableNode&lt;int, int&gt;* tmp = ht.Find(54);
    //cout &lt;&lt; &quot;Find?&quot; &lt;&lt; tmp-&gt;_key &lt;&lt; &quot;:&quot; &lt;&lt; tmp-&gt;_value &lt;&lt; endl;

    HashTable&lt;int, int&gt; ht1(ht);
    ht1.Print();

    HashTable&lt;int, int&gt; ht2;
    ht2 = ht1;
    ht2.Print();

    HashTable&lt;string, string&gt; htstr(10);
    htstr.Insert(&quot;字典&quot;,&quot;dictionary&quot;);
    htstr.Insert(&quot;清除&quot;, &quot;clear,destroy&quot;);
    htstr.Insert(&quot;手机&quot;, &quot;mobilephone&quot;);
    htstr.Insert(&quot;电脑&quot;, &quot;pc&quot;);
    htstr.Insert(&quot;吸血鬼&quot;, &quot;vampire&quot;);
    htstr.Print();

    HashTable&lt;string, string&gt; htstr1(htstr);
    htstr1.Print();
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="十三先生" />
          <p class="site-author-name" itemprop="name">十三先生</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">24</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/caochenyao" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/5253614710/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十三先生</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
